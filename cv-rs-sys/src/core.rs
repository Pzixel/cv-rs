/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __MINGW64_VERSION_MAJOR: u32 = 5;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &'static [u8; 6usize] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const _M_AMD64: u32 = 100;
pub const _M_X64: u32 = 100;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_SEC_WARN_STR: &'static [u8; 92usize] =
    b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0";
pub const __MINGW_MSVC2005_DEPREC_STR : & 'static [ u8 ; 117usize ] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const __USE_CRTIMP: u32 = 1;
pub const USE___UUIDOF: u32 = 0;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1282;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __MINGW_HAS_DXSDK: u32 = 1;
pub const MINGW_HAS_DDRAW_H: u32 = 1;
pub const MINGW_DDRAW_VERSION: u32 = 7;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const PATH_MAX: u32 = 260;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const _I8_MIN: i32 = -128;
pub const _I8_MAX: u32 = 127;
pub const _UI8_MAX: u32 = 255;
pub const _I16_MIN: i32 = -32768;
pub const _I16_MAX: u32 = 32767;
pub const _UI16_MAX: u32 = 65535;
pub const _I32_MIN: i32 = -2147483648;
pub const _I32_MAX: u32 = 2147483647;
pub const _UI32_MAX: u32 = 4294967295;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const ULONG_LONG_MAX: i32 = -1;
pub const _I64_MIN: i64 = -9223372036854775808;
pub const _I64_MAX: u64 = 9223372036854775807;
pub const _UI64_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const CV_HAL_ERROR_OK: u32 = 0;
pub const CV_HAL_ERROR_NOT_IMPLEMENTED: u32 = 1;
pub const CV_HAL_ERROR_UNKNOWN: i32 = -1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const CV_CN_MAX: u32 = 512;
pub const CV_CN_SHIFT: u32 = 3;
pub const CV_DEPTH_MAX: u32 = 8;
pub const CV_8U: u32 = 0;
pub const CV_8S: u32 = 1;
pub const CV_16U: u32 = 2;
pub const CV_16S: u32 = 3;
pub const CV_32S: u32 = 4;
pub const CV_32F: u32 = 5;
pub const CV_64F: u32 = 6;
pub const CV_USRTYPE1: u32 = 7;
pub const CV_MAT_DEPTH_MASK: u32 = 7;
pub const CV_HAL_CMP_EQ: u32 = 0;
pub const CV_HAL_CMP_GT: u32 = 1;
pub const CV_HAL_CMP_GE: u32 = 2;
pub const CV_HAL_CMP_LT: u32 = 3;
pub const CV_HAL_CMP_LE: u32 = 4;
pub const CV_HAL_CMP_NE: u32 = 5;
pub const CV_HAL_BORDER_CONSTANT: u32 = 0;
pub const CV_HAL_BORDER_REPLICATE: u32 = 1;
pub const CV_HAL_BORDER_REFLECT: u32 = 2;
pub const CV_HAL_BORDER_WRAP: u32 = 3;
pub const CV_HAL_BORDER_REFLECT_101: u32 = 4;
pub const CV_HAL_BORDER_TRANSPARENT: u32 = 5;
pub const CV_HAL_BORDER_ISOLATED: u32 = 16;
pub const CV_HAL_DFT_INVERSE: u32 = 1;
pub const CV_HAL_DFT_SCALE: u32 = 2;
pub const CV_HAL_DFT_ROWS: u32 = 4;
pub const CV_HAL_DFT_COMPLEX_OUTPUT: u32 = 16;
pub const CV_HAL_DFT_REAL_OUTPUT: u32 = 32;
pub const CV_HAL_DFT_TWO_STAGE: u32 = 64;
pub const CV_HAL_DFT_STAGE_COLS: u32 = 128;
pub const CV_HAL_DFT_IS_CONTINUOUS: u32 = 512;
pub const CV_HAL_DFT_IS_INPLACE: u32 = 1024;
pub const CV_HAL_SVD_NO_UV: u32 = 1;
pub const CV_HAL_SVD_SHORT_UV: u32 = 2;
pub const CV_HAL_SVD_MODIFY_A: u32 = 4;
pub const CV_HAL_SVD_FULL_UV: u32 = 8;
pub const CV_HAL_GEMM_1_T: u32 = 1;
pub const CV_HAL_GEMM_2_T: u32 = 2;
pub const CV_HAL_GEMM_3_T: u32 = 4;
pub const CV_ENABLE_UNROLLED: u32 = 1;
pub const CV_CPU_NONE: u32 = 0;
pub const CV_CPU_MMX: u32 = 1;
pub const CV_CPU_SSE: u32 = 2;
pub const CV_CPU_SSE2: u32 = 3;
pub const CV_CPU_SSE3: u32 = 4;
pub const CV_CPU_SSSE3: u32 = 5;
pub const CV_CPU_SSE4_1: u32 = 6;
pub const CV_CPU_SSE4_2: u32 = 7;
pub const CV_CPU_POPCNT: u32 = 8;
pub const CV_CPU_FP16: u32 = 9;
pub const CV_CPU_AVX: u32 = 10;
pub const CV_CPU_AVX2: u32 = 11;
pub const CV_CPU_FMA3: u32 = 12;
pub const CV_CPU_AVX_512F: u32 = 13;
pub const CV_CPU_AVX_512BW: u32 = 14;
pub const CV_CPU_AVX_512CD: u32 = 15;
pub const CV_CPU_AVX_512DQ: u32 = 16;
pub const CV_CPU_AVX_512ER: u32 = 17;
pub const CV_CPU_AVX_512IFMA512: u32 = 18;
pub const CV_CPU_AVX_512PF: u32 = 19;
pub const CV_CPU_AVX_512VBMI: u32 = 20;
pub const CV_CPU_AVX_512VL: u32 = 21;
pub const CV_CPU_NEON: u32 = 100;
pub const CV_CPU_VSX: u32 = 200;
pub const CV_HARDWARE_MAX_FEATURE: u32 = 255;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const RAND_MAX: u32 = 32767;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _MAX_ENV: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _MAX_WAIT_MALLOC_CRT: u32 = 60000;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const CV_MMX: u32 = 1;
pub const CV_SSE: u32 = 1;
pub const CV_SSE2: u32 = 1;
pub const CV_SSE3: u32 = 0;
pub const CV_SSSE3: u32 = 0;
pub const CV_SSE4_1: u32 = 0;
pub const CV_SSE4_2: u32 = 0;
pub const CV_POPCNT: u32 = 0;
pub const CV_AVX: u32 = 0;
pub const CV_FP16: u32 = 0;
pub const CV_AVX2: u32 = 0;
pub const CV_FMA3: u32 = 0;
pub const CV_AVX_512F: u32 = 0;
pub const CV_AVX_512BW: u32 = 0;
pub const CV_AVX_512CD: u32 = 0;
pub const CV_AVX_512DQ: u32 = 0;
pub const CV_AVX_512ER: u32 = 0;
pub const CV_AVX_512IFMA512: u32 = 0;
pub const CV_AVX_512PF: u32 = 0;
pub const CV_AVX_512VBMI: u32 = 0;
pub const CV_AVX_512VL: u32 = 0;
pub const CV_NEON: u32 = 0;
pub const CV_VSX: u32 = 0;
pub const CV_PI: f64 = 3.141592653589793;
pub const CV_2PI: f64 = 6.283185307179586;
pub const CV_LOG2: f64 = 0.6931471805599453;
pub const CV_FP16_TYPE: u32 = 0;
pub const OPENCV_ABI_COMPATIBILITY: u32 = 300;
pub const CV_MAT_CN_MASK: u32 = 4088;
pub const CV_MAT_TYPE_MASK: u32 = 4095;
pub const CV_MAT_CONT_FLAG_SHIFT: u32 = 14;
pub const CV_MAT_CONT_FLAG: u32 = 16384;
pub const CV_SUBMAT_FLAG_SHIFT: u32 = 15;
pub const CV_SUBMAT_FLAG: u32 = 32768;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const _MCW_DN: u32 = 50331648;
pub const _MCW_EM: u32 = 524319;
pub const _MCW_IC: u32 = 262144;
pub const _MCW_RC: u32 = 768;
pub const _MCW_PC: u32 = 196608;
pub const _DN_SAVE: u32 = 0;
pub const _DN_FLUSH: u32 = 16777216;
pub const _EM_INVALID: u32 = 16;
pub const _EM_DENORMAL: u32 = 524288;
pub const _EM_ZERODIVIDE: u32 = 8;
pub const _EM_OVERFLOW: u32 = 4;
pub const _EM_UNDERFLOW: u32 = 2;
pub const _EM_INEXACT: u32 = 1;
pub const _IC_AFFINE: u32 = 262144;
pub const _IC_PROJECTIVE: u32 = 0;
pub const _RC_CHOP: u32 = 768;
pub const _RC_UP: u32 = 512;
pub const _RC_DOWN: u32 = 256;
pub const _RC_NEAR: u32 = 0;
pub const _PC_24: u32 = 131072;
pub const _PC_53: u32 = 65536;
pub const _PC_64: u32 = 0;
pub const __MINGW_FPCLASS_DEFINED: u32 = 1;
pub const _FPCLASS_SNAN: u32 = 1;
pub const _FPCLASS_QNAN: u32 = 2;
pub const _FPCLASS_NINF: u32 = 4;
pub const _FPCLASS_NN: u32 = 8;
pub const _FPCLASS_ND: u32 = 16;
pub const _FPCLASS_NZ: u32 = 32;
pub const _FPCLASS_PZ: u32 = 64;
pub const _FPCLASS_PD: u32 = 128;
pub const _FPCLASS_PN: u32 = 256;
pub const _FPCLASS_PINF: u32 = 512;
pub const _SW_UNEMULATED: u32 = 64;
pub const _SW_SQRTNEG: u32 = 128;
pub const _SW_STACKOVERFLOW: u32 = 512;
pub const _SW_STACKUNDERFLOW: u32 = 1024;
pub const _FPE_INVALID: u32 = 129;
pub const _FPE_DENORMAL: u32 = 130;
pub const _FPE_ZERODIVIDE: u32 = 131;
pub const _FPE_OVERFLOW: u32 = 132;
pub const _FPE_UNDERFLOW: u32 = 133;
pub const _FPE_INEXACT: u32 = 134;
pub const _FPE_UNEMULATED: u32 = 135;
pub const _FPE_SQRTNEG: u32 = 136;
pub const _FPE_STACKOVERFLOW: u32 = 138;
pub const _FPE_STACKUNDERFLOW: u32 = 139;
pub const _FPE_EXPLICITGEN: u32 = 140;
pub const MCW_PC: u32 = 196608;
pub const PC_24: u32 = 131072;
pub const PC_53: u32 = 65536;
pub const PC_64: u32 = 0;
pub const _CW_DEFAULT: u32 = 524319;
pub const CV_RNG_COEFF: u32 = 4164903690;
pub const IPL_DEPTH_SIGN: u32 = 2147483648;
pub const IPL_DEPTH_1U: u32 = 1;
pub const IPL_DEPTH_8U: u32 = 8;
pub const IPL_DEPTH_16U: u32 = 16;
pub const IPL_DEPTH_32F: u32 = 32;
pub const IPL_DEPTH_8S: u32 = 2147483656;
pub const IPL_DEPTH_16S: u32 = 2147483664;
pub const IPL_DEPTH_32S: u32 = 2147483680;
pub const IPL_DATA_ORDER_PIXEL: u32 = 0;
pub const IPL_DATA_ORDER_PLANE: u32 = 1;
pub const IPL_ORIGIN_TL: u32 = 0;
pub const IPL_ORIGIN_BL: u32 = 1;
pub const IPL_ALIGN_4BYTES: u32 = 4;
pub const IPL_ALIGN_8BYTES: u32 = 8;
pub const IPL_ALIGN_16BYTES: u32 = 16;
pub const IPL_ALIGN_32BYTES: u32 = 32;
pub const IPL_ALIGN_DWORD: u32 = 4;
pub const IPL_ALIGN_QWORD: u32 = 8;
pub const IPL_BORDER_CONSTANT: u32 = 0;
pub const IPL_BORDER_REPLICATE: u32 = 1;
pub const IPL_BORDER_REFLECT: u32 = 2;
pub const IPL_BORDER_WRAP: u32 = 3;
pub const IPL_IMAGE_HEADER: u32 = 1;
pub const IPL_IMAGE_DATA: u32 = 2;
pub const IPL_IMAGE_ROI: u32 = 4;
pub const IPL_BORDER_REFLECT_101: u32 = 4;
pub const IPL_BORDER_TRANSPARENT: u32 = 5;
pub const CV_TYPE_NAME_IMAGE: &'static [u8; 13usize] = b"opencv-image\0";
pub const IPL_DEPTH_64F: u32 = 64;
pub const CV_AUTO_STEP: u32 = 2147483647;
pub const CV_MAGIC_MASK: u32 = 4294901760;
pub const CV_MAT_MAGIC_VAL: u32 = 1111621632;
pub const CV_TYPE_NAME_MAT: &'static [u8; 14usize] = b"opencv-matrix\0";
pub const CV_MATND_MAGIC_VAL: u32 = 1111687168;
pub const CV_TYPE_NAME_MATND: &'static [u8; 17usize] = b"opencv-nd-matrix\0";
pub const CV_MAX_DIM: u32 = 32;
pub const CV_MAX_DIM_HEAP: u32 = 1024;
pub const CV_SPARSE_MAT_MAGIC_VAL: u32 = 1111752704;
pub const CV_TYPE_NAME_SPARSE_MAT: &'static [u8; 21usize] = b"opencv-sparse-matrix\0";
pub const CV_HIST_MAGIC_VAL: u32 = 1111818240;
pub const CV_HIST_UNIFORM_FLAG: u32 = 1024;
pub const CV_HIST_RANGES_FLAG: u32 = 2048;
pub const CV_HIST_ARRAY: u32 = 0;
pub const CV_HIST_SPARSE: u32 = 1;
pub const CV_HIST_TREE: u32 = 1;
pub const CV_HIST_UNIFORM: u32 = 1;
pub const CV_TERMCRIT_ITER: u32 = 1;
pub const CV_TERMCRIT_NUMBER: u32 = 1;
pub const CV_TERMCRIT_EPS: u32 = 2;
pub const CV_WHOLE_SEQ_END_INDEX: u32 = 1073741823;
pub const CV_STORAGE_MAGIC_VAL: u32 = 1116274688;
pub const CV_TYPE_NAME_SEQ: &'static [u8; 16usize] = b"opencv-sequence\0";
pub const CV_TYPE_NAME_SEQ_TREE: &'static [u8; 21usize] = b"opencv-sequence-tree\0";
pub const CV_SET_ELEM_IDX_MASK: u32 = 67108863;
pub const CV_TYPE_NAME_GRAPH: &'static [u8; 13usize] = b"opencv-graph\0";
pub const CV_SEQ_MAGIC_VAL: u32 = 1117323264;
pub const CV_SET_MAGIC_VAL: u32 = 1117257728;
pub const CV_SEQ_ELTYPE_BITS: u32 = 12;
pub const CV_SEQ_ELTYPE_MASK: u32 = 4095;
pub const CV_SEQ_ELTYPE_GENERIC: u32 = 0;
pub const CV_SEQ_ELTYPE_PTR: u32 = 7;
pub const CV_SEQ_ELTYPE_PPOINT: u32 = 7;
pub const CV_SEQ_ELTYPE_GRAPH_EDGE: u32 = 0;
pub const CV_SEQ_ELTYPE_GRAPH_VERTEX: u32 = 0;
pub const CV_SEQ_ELTYPE_TRIAN_ATR: u32 = 0;
pub const CV_SEQ_ELTYPE_CONNECTED_COMP: u32 = 0;
pub const CV_SEQ_KIND_BITS: u32 = 2;
pub const CV_SEQ_KIND_MASK: u32 = 12288;
pub const CV_SEQ_KIND_GENERIC: u32 = 0;
pub const CV_SEQ_KIND_CURVE: u32 = 4096;
pub const CV_SEQ_KIND_BIN_TREE: u32 = 8192;
pub const CV_SEQ_KIND_GRAPH: u32 = 4096;
pub const CV_SEQ_KIND_SUBDIV2D: u32 = 8192;
pub const CV_SEQ_FLAG_SHIFT: u32 = 14;
pub const CV_SEQ_FLAG_CLOSED: u32 = 16384;
pub const CV_SEQ_FLAG_SIMPLE: u32 = 0;
pub const CV_SEQ_FLAG_CONVEX: u32 = 0;
pub const CV_SEQ_FLAG_HOLE: u32 = 32768;
pub const CV_GRAPH_FLAG_ORIENTED: u32 = 16384;
pub const CV_GRAPH: u32 = 4096;
pub const CV_ORIENTED_GRAPH: u32 = 20480;
pub const CV_SEQ_POLYGON_TREE: u32 = 8192;
pub const CV_SEQ_CONNECTED_COMP: u32 = 0;
pub const CV_STORAGE_READ: u32 = 0;
pub const CV_STORAGE_WRITE: u32 = 1;
pub const CV_STORAGE_WRITE_TEXT: u32 = 1;
pub const CV_STORAGE_WRITE_BINARY: u32 = 1;
pub const CV_STORAGE_APPEND: u32 = 2;
pub const CV_STORAGE_MEMORY: u32 = 4;
pub const CV_STORAGE_FORMAT_MASK: u32 = 56;
pub const CV_STORAGE_FORMAT_AUTO: u32 = 0;
pub const CV_STORAGE_FORMAT_XML: u32 = 8;
pub const CV_STORAGE_FORMAT_YAML: u32 = 16;
pub const CV_STORAGE_FORMAT_JSON: u32 = 24;
pub const CV_STORAGE_BASE64: u32 = 64;
pub const CV_STORAGE_WRITE_BASE64: u32 = 65;
pub const CV_NODE_NONE: u32 = 0;
pub const CV_NODE_INT: u32 = 1;
pub const CV_NODE_INTEGER: u32 = 1;
pub const CV_NODE_REAL: u32 = 2;
pub const CV_NODE_FLOAT: u32 = 2;
pub const CV_NODE_STR: u32 = 3;
pub const CV_NODE_STRING: u32 = 3;
pub const CV_NODE_REF: u32 = 4;
pub const CV_NODE_SEQ: u32 = 5;
pub const CV_NODE_MAP: u32 = 6;
pub const CV_NODE_TYPE_MASK: u32 = 7;
pub const CV_NODE_FLOW: u32 = 8;
pub const CV_NODE_USER: u32 = 16;
pub const CV_NODE_EMPTY: u32 = 32;
pub const CV_NODE_NAMED: u32 = 64;
pub const CV_NODE_SEQ_SIMPLE: u32 = 256;
pub const CV_AUTOSTEP: u32 = 2147483647;
pub const CV_MAX_ARR: u32 = 10;
pub const CV_NO_DEPTH_CHECK: u32 = 1;
pub const CV_NO_CN_CHECK: u32 = 2;
pub const CV_NO_SIZE_CHECK: u32 = 4;
pub const CV_CMP_EQ: u32 = 0;
pub const CV_CMP_GT: u32 = 1;
pub const CV_CMP_GE: u32 = 2;
pub const CV_CMP_LT: u32 = 3;
pub const CV_CMP_LE: u32 = 4;
pub const CV_CMP_NE: u32 = 5;
pub const CV_CHECK_RANGE: u32 = 1;
pub const CV_CHECK_QUIET: u32 = 2;
pub const CV_RAND_UNI: u32 = 0;
pub const CV_RAND_NORMAL: u32 = 1;
pub const CV_SORT_EVERY_ROW: u32 = 0;
pub const CV_SORT_EVERY_COLUMN: u32 = 1;
pub const CV_SORT_ASCENDING: u32 = 0;
pub const CV_SORT_DESCENDING: u32 = 16;
pub const CV_GEMM_A_T: u32 = 1;
pub const CV_GEMM_B_T: u32 = 2;
pub const CV_GEMM_C_T: u32 = 4;
pub const CV_SVD_MODIFY_A: u32 = 1;
pub const CV_SVD_U_T: u32 = 2;
pub const CV_SVD_V_T: u32 = 4;
pub const CV_LU: u32 = 0;
pub const CV_SVD: u32 = 1;
pub const CV_SVD_SYM: u32 = 2;
pub const CV_CHOLESKY: u32 = 3;
pub const CV_QR: u32 = 4;
pub const CV_NORMAL: u32 = 16;
pub const CV_COVAR_SCRAMBLED: u32 = 0;
pub const CV_COVAR_NORMAL: u32 = 1;
pub const CV_COVAR_USE_AVG: u32 = 2;
pub const CV_COVAR_SCALE: u32 = 4;
pub const CV_COVAR_ROWS: u32 = 8;
pub const CV_COVAR_COLS: u32 = 16;
pub const CV_PCA_DATA_AS_ROW: u32 = 0;
pub const CV_PCA_DATA_AS_COL: u32 = 1;
pub const CV_PCA_USE_AVG: u32 = 2;
pub const CV_C: u32 = 1;
pub const CV_L1: u32 = 2;
pub const CV_L2: u32 = 4;
pub const CV_NORM_MASK: u32 = 7;
pub const CV_RELATIVE: u32 = 8;
pub const CV_DIFF: u32 = 16;
pub const CV_MINMAX: u32 = 32;
pub const CV_DIFF_C: u32 = 17;
pub const CV_DIFF_L1: u32 = 18;
pub const CV_DIFF_L2: u32 = 20;
pub const CV_RELATIVE_C: u32 = 9;
pub const CV_RELATIVE_L1: u32 = 10;
pub const CV_RELATIVE_L2: u32 = 12;
pub const CV_REDUCE_SUM: u32 = 0;
pub const CV_REDUCE_AVG: u32 = 1;
pub const CV_REDUCE_MAX: u32 = 2;
pub const CV_REDUCE_MIN: u32 = 3;
pub const CV_DXT_FORWARD: u32 = 0;
pub const CV_DXT_INVERSE: u32 = 1;
pub const CV_DXT_SCALE: u32 = 2;
pub const CV_DXT_INV_SCALE: u32 = 3;
pub const CV_DXT_INVERSE_SCALE: u32 = 3;
pub const CV_DXT_ROWS: u32 = 4;
pub const CV_DXT_MUL_CONJ: u32 = 8;
pub const CV_FRONT: u32 = 1;
pub const CV_BACK: u32 = 0;
pub const CV_GRAPH_VERTEX: u32 = 1;
pub const CV_GRAPH_TREE_EDGE: u32 = 2;
pub const CV_GRAPH_BACK_EDGE: u32 = 4;
pub const CV_GRAPH_FORWARD_EDGE: u32 = 8;
pub const CV_GRAPH_CROSS_EDGE: u32 = 16;
pub const CV_GRAPH_ANY_EDGE: u32 = 30;
pub const CV_GRAPH_NEW_TREE: u32 = 32;
pub const CV_GRAPH_BACKTRACKING: u32 = 64;
pub const CV_GRAPH_OVER: i32 = -1;
pub const CV_GRAPH_ALL_ITEMS: i32 = -1;
pub const CV_GRAPH_ITEM_VISITED_FLAG: u32 = 1073741824;
pub const CV_GRAPH_SEARCH_TREE_NODE_FLAG: u32 = 536870912;
pub const CV_GRAPH_FORWARD_EDGE_FLAG: u32 = 268435456;
pub const CV_KMEANS_USE_INITIAL_LABELS: u32 = 1;
pub const CV_ErrModeLeaf: u32 = 0;
pub const CV_ErrModeParent: u32 = 1;
pub const CV_ErrModeSilent: u32 = 2;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type rsize_t = usize;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
    assert_eq!(
        ::std::mem::size_of::<localeinfo_struct>(),
        16usize,
        concat!("Size of: ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<localeinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<localeinfo_struct>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<localeinfo_struct>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
    assert_eq!(
        ::std::mem::size_of::<tagLC_ID>(),
        6usize,
        concat!("Size of: ", stringify!(tagLC_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<tagLC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(tagLC_ID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wLanguage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wLanguage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wCountry as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCountry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wCodePage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCodePage)
        )
    );
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut wchar_t,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).locale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wlocale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wlocale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wrefcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wrefcount)
        )
    );
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct>(),
        352usize,
        concat!("Size of: ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct>(),
        8usize,
        concat!("Alignment of ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_codepage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_codepage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_collate_cp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_collate_cp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_handle as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_category as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_clike as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_clike)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).mb_cur_max as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_intl_refcount as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_intl_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_num_refcount as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_num_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_mon_refcount as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_mon_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).ctype1_refcount as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).ctype1 as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pctype as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pctype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pclmap as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pclmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pcumap as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pcumap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_time_curr as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_time_curr)
        )
    );
}
pub type threadlocinfo = threadlocaleinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
    pub __bindgen_padding_1: u64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type uint = u32;
pub type schar = ::std::os::raw::c_schar;
pub type uchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type int64 = i64;
pub type uint64 = u64;
pub const CpuFeatures_CPU_MMX: CpuFeatures = 1;
pub const CpuFeatures_CPU_SSE: CpuFeatures = 2;
pub const CpuFeatures_CPU_SSE2: CpuFeatures = 3;
pub const CpuFeatures_CPU_SSE3: CpuFeatures = 4;
pub const CpuFeatures_CPU_SSSE3: CpuFeatures = 5;
pub const CpuFeatures_CPU_SSE4_1: CpuFeatures = 6;
pub const CpuFeatures_CPU_SSE4_2: CpuFeatures = 7;
pub const CpuFeatures_CPU_POPCNT: CpuFeatures = 8;
pub const CpuFeatures_CPU_FP16: CpuFeatures = 9;
pub const CpuFeatures_CPU_AVX: CpuFeatures = 10;
pub const CpuFeatures_CPU_AVX2: CpuFeatures = 11;
pub const CpuFeatures_CPU_FMA3: CpuFeatures = 12;
pub const CpuFeatures_CPU_AVX_512F: CpuFeatures = 13;
pub const CpuFeatures_CPU_AVX_512BW: CpuFeatures = 14;
pub const CpuFeatures_CPU_AVX_512CD: CpuFeatures = 15;
pub const CpuFeatures_CPU_AVX_512DQ: CpuFeatures = 16;
pub const CpuFeatures_CPU_AVX_512ER: CpuFeatures = 17;
pub const CpuFeatures_CPU_AVX_512IFMA512: CpuFeatures = 18;
pub const CpuFeatures_CPU_AVX_512PF: CpuFeatures = 19;
pub const CpuFeatures_CPU_AVX_512VBMI: CpuFeatures = 20;
pub const CpuFeatures_CPU_AVX_512VL: CpuFeatures = 21;
pub const CpuFeatures_CPU_NEON: CpuFeatures = 100;
pub const CpuFeatures_CPU_VSX: CpuFeatures = 200;
/// @brief Available CPU features.
pub type CpuFeatures = u32;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDOUBLE>())).ld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_DOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_FLOAT>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
    pub __bindgen_padding_0: u64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        16usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LONGDOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDBL12>())).ld12 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__imp___mb_cur_max"]
    pub static mut __imp___mb_cur_max: *mut ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_invalid_parameter_handler(_Handler: _invalid_parameter_handler) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    #[link_name = "\u{1}_sys_errlist"]
    pub static mut _sys_errlist: [*mut ::std::os::raw::c_char; 1usize];
}
extern "C" {
    #[link_name = "\u{1}_sys_nerr"]
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__imp___argc"]
    pub static mut __imp___argc: *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__imp___argv"]
    pub static mut __imp___argv: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__imp___wargv"]
    pub static mut __imp___wargv: *mut *mut *mut wchar_t;
}
extern "C" {
    #[link_name = "\u{1}__imp__environ"]
    pub static mut __imp__environ: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__imp__wenviron"]
    pub static mut __imp__wenviron: *mut *mut *mut wchar_t;
}
extern "C" {
    #[link_name = "\u{1}__imp__pgmptr"]
    pub static mut __imp__pgmptr: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__imp__wpgmptr"]
    pub static mut __imp__wpgmptr: *mut *mut wchar_t;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    #[link_name = "\u{1}__imp__fmode"]
    pub static mut __imp__fmode: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    #[link_name = "\u{1}__imp__osplatform"]
    pub static mut __imp__osplatform: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__imp__osver"]
    pub static mut __imp__osver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__imp__winver"]
    pub static mut __imp__winver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__imp__winmajor"]
    pub static mut __imp__winmajor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__imp__winminor"]
    pub static mut __imp__winminor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_osplatform(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_osver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winmajor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winminor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(_Flags: ::std::os::raw::c_uint, _Mask: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _abs64(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn atoi(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
                -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
                -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _byteswap_ushort(_Short: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Long: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Int64: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(_Str: *const ::std::os::raw::c_char, _MaxCount: usize, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(_Dest: *mut wchar_t, _Source: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mkstemp(template_name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(_Str: *const ::std::os::raw::c_char, _EndPtr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(nptr: *const ::std::os::raw::c_char, endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __strtod(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __mingw_strtof(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __mingw_strtod(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __mingw_strtold(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(_Dest: *mut ::std::os::raw::c_char, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn calloc(_NumOfElements: usize, _SizeOfElements: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(_Memory: *mut ::std::os::raw::c_void, _NewSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(_Memory: *mut ::std::os::raw::c_void, _Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(_Size: usize, _Alignment: usize, _Offset: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow(_Value: ::std::os::raw::c_int, _Dest: *mut wchar_t, _Radix: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow(_Value: ::std::os::raw::c_long, _Dest: *mut wchar_t, _Radix: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow(_Value: ::std::os::raw::c_ulong, _Dest: *mut wchar_t, _Radix: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn __mingw_wcstod(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn __mingw_wcstof(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn __mingw_wcstold(arg1: *const wchar_t, arg2: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstod(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(arg1: *const wchar_t, arg2: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn wcstol(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtof(_Str: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_Str: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_Str: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_Str: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _i64tow(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_Str: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fullpath(
        _FullPath: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atodbl(_Result: *mut _CRT_DOUBLE, _Str: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(_Result: *mut _LDOUBLE, _Str: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt(_Result: *mut _CRT_FLOAT, _Str: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lrotl(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _lrotr(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _makepath(
        _Path: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _rotl64(_Val: ::std::os::raw::c_ulonglong, _Shift: ::std::os::raw::c_int) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr64(Value: ::std::os::raw::c_ulonglong, Shift: ::std::os::raw::c_int) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(_Val: ::std::os::raw::c_uint, _Shift: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl(_Val: ::std::os::raw::c_uint, _Shift: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _wfullpath(_FullPath: *mut wchar_t, _Path: *const wchar_t, _SizeInWords: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath(
        _ResultPath: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrMsg: *const wchar_t);
}
extern "C" {
    pub fn _wsearchenv(_Filename: *const wchar_t, _EnvVar: *const wchar_t, _ResultPath: *mut wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Val: ::std::os::raw::c_ulong,
        _Dstbuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wtoll(arg1: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lltoa(
        arg1: ::std::os::raw::c_longlong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ulltoa(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lltow(arg1: ::std::os::raw::c_longlong, arg2: *mut wchar_t, arg3: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn ulltow(arg1: ::std::os::raw::c_ulonglong, arg2: *mut wchar_t, arg3: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _dupenv_s(
        _PBuffer: *mut *mut ::std::os::raw::c_char,
        _PBufferSizeInBytes: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow_s(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _ReturnSize: *mut usize,
        _DstBuf: *mut wchar_t,
        _DstSizeInWords: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(_Buffer: *mut *mut wchar_t, _BufferSizeInWords: *mut usize, _VarName: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _i64tow_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDights: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath_s(
        _PathResult: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _putenv_s(_Name: *const ::std::os::raw::c_char, _Value: *const ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveSize: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirSize: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameSize: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtSize: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _PathResult: *mut wchar_t,
        _SizeInWords: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _EnvVar: *const wchar_t,
        _ResultPath: *mut wchar_t,
        _SizeInWords: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveSizeInWords: usize,
        _Dir: *mut wchar_t,
        _DirSizeInWords: usize,
        _Filename: *mut wchar_t,
        _FilenameSizeInWords: usize,
        _Ext: *mut wchar_t,
        _ExtSizeInWords: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    assert_eq!(
        ::std::mem::size_of::<_heapinfo>(),
        24usize,
        concat!("Size of: ", stringify!(_heapinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_heapinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_heapinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_heapinfo>()))._pentry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_pentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_heapinfo>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_heapinfo>()))._useflag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_useflag)
        )
    );
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    #[link_name = "\u{1}_amblksiz"]
    pub static mut _amblksiz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __mingw_aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __mingw_aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_malloc_crt_max_wait(_NewValue: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _expand(_Memory: *mut ::std::os::raw::c_void, _NewSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize(_Memory: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _get_sbh_threshold() -> usize;
}
extern "C" {
    pub fn _set_sbh_threshold(_NewValue: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_amblksiz(_Value: usize) -> errno_t;
}
extern "C" {
    pub fn _get_amblksiz(_Value: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _heapadd(_Memory: *mut ::std::os::raw::c_void, _Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapset(_Fill: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapused(_Used: *mut usize, _Commit: *mut usize) -> usize;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv16suf {
    pub i: ::std::os::raw::c_short,
    pub fmt: Cv16suf__fp16Format,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cv16suf__fp16Format {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_padding_0: u16,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_Cv16suf__fp16Format() {
    assert_eq!(
        ::std::mem::size_of::<Cv16suf__fp16Format>(),
        4usize,
        concat!("Size of: ", stringify!(Cv16suf__fp16Format))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv16suf__fp16Format>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv16suf__fp16Format))
    );
}
impl Cv16suf__fp16Format {
    #[inline]
    pub fn significand(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_significand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn exponent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_exponent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        significand: ::std::os::raw::c_uint,
        exponent: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let significand: u32 = unsafe { ::std::mem::transmute(significand) };
            significand as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let exponent: u32 = unsafe { ::std::mem::transmute(exponent) };
            exponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_Cv16suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv16suf>(),
        4usize,
        concat!("Size of: ", stringify!(Cv16suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv16suf>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv16suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv16suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv16suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv16suf>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv16suf),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv32suf {
    pub i: ::std::os::raw::c_int,
    pub u: ::std::os::raw::c_uint,
    pub f: f32,
    pub fmt: Cv32suf__fp32Format,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cv32suf__fp32Format {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_Cv32suf__fp32Format() {
    assert_eq!(
        ::std::mem::size_of::<Cv32suf__fp32Format>(),
        4usize,
        concat!("Size of: ", stringify!(Cv32suf__fp32Format))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv32suf__fp32Format>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv32suf__fp32Format))
    );
}
impl Cv32suf__fp32Format {
    #[inline]
    pub fn significand(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_significand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn exponent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_exponent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        significand: ::std::os::raw::c_uint,
        exponent: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let significand: u32 = unsafe { ::std::mem::transmute(significand) };
            significand as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let exponent: u32 = unsafe { ::std::mem::transmute(exponent) };
            exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_Cv32suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv32suf>(),
        4usize,
        concat!("Size of: ", stringify!(Cv32suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv32suf>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv32suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv64suf {
    pub i: int64,
    pub u: uint64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Cv64suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv64suf>(),
        8usize,
        concat!("Size of: ", stringify!(Cv64suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv64suf>(),
        8usize,
        concat!("Alignment of ", stringify!(Cv64suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(f)
        )
    );
}
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _assert(
        _Message: *const ::std::os::raw::c_char,
        _File: *const ::std::os::raw::c_char,
        _Line: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy_s(
        _dest: *mut ::std::os::raw::c_void,
        _numberOfElements: usize,
        _src: *const ::std::os::raw::c_void,
        _count: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mempcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strset(_Str: *mut ::std::os::raw::c_char, _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_l(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcpy(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(_Str1: *const ::std::os::raw::c_char, _Str2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _strdup(_Src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(_Str: *const ::std::os::raw::c_char, _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(_Str1: *const ::std::os::raw::c_char, _Str2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strerror(_ErrMsg: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr_l(_String: *mut ::std::os::raw::c_char, _Locale: _locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset_l(
        str: *mut ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
        count: usize,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(_Str: *const ::std::os::raw::c_char, _Ch: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        __last: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_l(_String: *mut ::std::os::raw::c_char, _Locale: _locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Dst: *mut ::std::os::raw::c_char,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Dst: *mut ::std::os::raw::c_char,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_Src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(_Str1: *const ::std::os::raw::c_char, _Str2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(_Str1: *const ::std::os::raw::c_char, _Str2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(_Str: *mut ::std::os::raw::c_char, _Val: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _wcsdup(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Dest: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcscmp(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Dest: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_Str: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_Str: *const wchar_t) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Src: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Dest: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(_Str1: *const wchar_t, _Str2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Dest: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsncpy_l(_Dest: *mut wchar_t, _Source: *const wchar_t, _Count: usize, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_Str: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_Str: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(_Str: *mut wchar_t, _Delim: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrNum: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsicmp(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(_Str1: *const wchar_t, _Str2: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(_Str1: *const wchar_t, _Str2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset(_Str: *mut wchar_t, _Val: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset(_Str: *mut wchar_t, _Val: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Dst: *mut wchar_t, _Src: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(_Dst: *mut wchar_t, _Src: *const wchar_t, _MaxCount: usize, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn wcscoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(_Str1: *const wchar_t, _Str2: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(_Str1: *const wchar_t, _Str2: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(_Str1: *const wchar_t, _Str2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(_Str1: *const wchar_t, _Str2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(_Str1: *const wchar_t, _Str2: *const wchar_t, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_Str: *mut wchar_t, _Val: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_Str: *mut wchar_t, _Val: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strset_s(_Dst: *mut ::std::os::raw::c_char, _DstSize: usize, _Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _strerror_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrMsg: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrNum: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_s(_Str: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr_s_l(_Str: *mut ::std::os::raw::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strnset_s(
        _Str: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_s(_Str: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr_s_l(_Str: *mut ::std::os::raw::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strncat_s_l(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strcpy_s(
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Src: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strncpy_s_l(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtok_s_l(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat_s(
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Src: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn memmove_s(
        _dest: *mut ::std::os::raw::c_void,
        _numberOfElements: usize,
        _src: *const ::std::os::raw::c_void,
        _count: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_Str: *mut wchar_t, _Delim: *const wchar_t, _Context: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(_Buf: *mut wchar_t, _SizeInWords: usize, _ErrNum: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __wcserror_s(_Buffer: *mut wchar_t, _SizeInWords: usize, _ErrMsg: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s(_Dst: *mut wchar_t, _DstSizeInWords: usize, _Val: wchar_t, _MaxCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsset_s(_Str: *mut wchar_t, _SizeInWords: usize, _Val: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s(_Str: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_Str: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s(_Str: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_Str: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Dst: *mut wchar_t, _SizeInWords: rsize_t, _Src: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcscat_s(_Dst: *mut wchar_t, _SizeInWords: rsize_t, _Src: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(_Dst: *mut wchar_t, _DstSizeInChars: usize, _Src: *const wchar_t, _MaxCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsncat_s_l(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(_Dst: *mut wchar_t, _DstSizeInChars: usize, _Src: *const wchar_t, _MaxCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsncpy_s_l(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstok_s_l(
        _Str: *mut wchar_t,
        _Delim: *const wchar_t,
        _Context: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s_l(
        _Str: *mut wchar_t,
        _SizeInChars: usize,
        _Val: ::std::os::raw::c_uint,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s_l(
        _Str: *mut wchar_t,
        _SizeInChars: usize,
        _Val: ::std::os::raw::c_uint,
        _Count: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _controlfp(unNew: ::std::os::raw::c_uint, unMask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _controlfp_s(
        _CurrentState: *mut ::std::os::raw::c_uint,
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> errno_t;
}
extern "C" {
    pub fn _control87(unNew: ::std::os::raw::c_uint, unMask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _clearfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _statusfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _fpreset();
}
extern "C" {
    pub fn fpreset();
}
extern "C" {
    pub fn __fpecode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn _nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn _scalb(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn _finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclass(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnan(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _chgsignl(arg1: f64) -> f64;
}
/// @brief This is the "metatype" used *only* as a function parameter.
///
/// It denotes that the function accepts arrays of multiple types, such as IplImage*, CvMat* or even
/// CvSeq* sometimes. The particular array type is determined at runtime by analyzing the first 4
/// bytes of the header. In C++ interface the role of CvArr is played by InputArray and OutputArray.
pub type CvArr = ::std::os::raw::c_void;
pub type CVStatus = ::std::os::raw::c_int;
/// < everything is ok
pub const CV_StsOk: _bindgen_ty_1 = 0;
/// < pseudo error for back trace
pub const CV_StsBackTrace: _bindgen_ty_1 = -1;
/// < unknown /unspecified error
pub const CV_StsError: _bindgen_ty_1 = -2;
/// < internal error (bad state)
pub const CV_StsInternal: _bindgen_ty_1 = -3;
/// < insufficient memory
pub const CV_StsNoMem: _bindgen_ty_1 = -4;
/// < function arg/param is bad
pub const CV_StsBadArg: _bindgen_ty_1 = -5;
/// < unsupported function
pub const CV_StsBadFunc: _bindgen_ty_1 = -6;
/// < iter. didn't converge
pub const CV_StsNoConv: _bindgen_ty_1 = -7;
/// < tracing
pub const CV_StsAutoTrace: _bindgen_ty_1 = -8;
/// < image header is NULL
pub const CV_HeaderIsNull: _bindgen_ty_1 = -9;
/// < image size is invalid
pub const CV_BadImageSize: _bindgen_ty_1 = -10;
/// < offset is invalid
pub const CV_BadOffset: _bindgen_ty_1 = -11;
pub const CV_BadDataPtr: _bindgen_ty_1 = -12;
/// < image step is wrong, this may happen for a non-continuous matrix
pub const CV_BadStep: _bindgen_ty_1 = -13;
pub const CV_BadModelOrChSeq: _bindgen_ty_1 = -14;
/// < bad number of channels, for example, some functions accept only single channel matrices
pub const CV_BadNumChannels: _bindgen_ty_1 = -15;
pub const CV_BadNumChannel1U: _bindgen_ty_1 = -16;
/// < input image depth is not supported by the function
pub const CV_BadDepth: _bindgen_ty_1 = -17;
pub const CV_BadAlphaChannel: _bindgen_ty_1 = -18;
/// < number of dimensions is out of range
pub const CV_BadOrder: _bindgen_ty_1 = -19;
/// < incorrect input origin
pub const CV_BadOrigin: _bindgen_ty_1 = -20;
/// < incorrect input align
pub const CV_BadAlign: _bindgen_ty_1 = -21;
pub const CV_BadCallBack: _bindgen_ty_1 = -22;

pub const CV_BadTileSize: _bindgen_ty_1 = -23;
/// < input COI is not supported
pub const CV_BadCOI: _bindgen_ty_1 = -24;
/// < incorrect input roi
pub const CV_BadROISize: _bindgen_ty_1 = -25;
pub const CV_MaskIsTiled: _bindgen_ty_1 = -26;
/// < null pointer
pub const CV_StsNullPtr: _bindgen_ty_1 = -27;
/// < incorrect vector length
pub const CV_StsVecLengthErr: _bindgen_ty_1 = -28;
/// < incorrect filter structure content
pub const CV_StsFilterStructContentErr: _bindgen_ty_1 = -29;
/// < incorrect transform kernel content
pub const CV_StsKernelStructContentErr: _bindgen_ty_1 = -30;
/// < incorrect filter offset value
pub const CV_StsFilterOffsetErr: _bindgen_ty_1 = -31;
/// < the input/output structure size is incorrect
pub const CV_StsBadSize: _bindgen_ty_1 = -201;
/// < division by zero
pub const CV_StsDivByZero: _bindgen_ty_1 = -202;
/// < in-place operation is not supported
pub const CV_StsInplaceNotSupported: _bindgen_ty_1 = -203;
/// < request can't be completed
pub const CV_StsObjectNotFound: _bindgen_ty_1 = -204;
/// < formats of input/output arrays differ
pub const CV_StsUnmatchedFormats: _bindgen_ty_1 = -205;
/// < flag is wrong or not supported
pub const CV_StsBadFlag: _bindgen_ty_1 = -206;
/// < bad CvPoint
pub const CV_StsBadPoint: _bindgen_ty_1 = -207;
/// < bad format of mask (neither 8uC1 nor 8sC1)
pub const CV_StsBadMask: _bindgen_ty_1 = -208;
/// < sizes of input/output structures do not match
pub const CV_StsUnmatchedSizes: _bindgen_ty_1 = -209;
/// < the data format/type is not supported by the function
pub const CV_StsUnsupportedFormat: _bindgen_ty_1 = -210;
/// < some of parameters are out of range
pub const CV_StsOutOfRange: _bindgen_ty_1 = -211;
/// < invalid syntax/structure of the parsed file
pub const CV_StsParseError: _bindgen_ty_1 = -212;
/// < the requested function/feature is not implemented
pub const CV_StsNotImplemented: _bindgen_ty_1 = -213;
/// < an allocated block has been corrupted
pub const CV_StsBadMemBlock: _bindgen_ty_1 = -214;
/// < assertion failed
pub const CV_StsAssert: _bindgen_ty_1 = -215;
/// < no CUDA support
pub const CV_GpuNotSupported: _bindgen_ty_1 = -216;
/// < GPU API call error
pub const CV_GpuApiCallError: _bindgen_ty_1 = -217;
/// < no OpenGL support
pub const CV_OpenGlNotSupported: _bindgen_ty_1 = -218;
/// < OpenGL API call error
pub const CV_OpenGlApiCallError: _bindgen_ty_1 = -219;
/// < OpenCL API call error
pub const CV_OpenCLApiCallError: _bindgen_ty_1 = -220;
pub const CV_OpenCLDoubleNotSupported: _bindgen_ty_1 = -221;
/// < OpenCL initialization error
pub const CV_OpenCLInitError: _bindgen_ty_1 = -222;
pub const CV_OpenCLNoAMDBlasFft: _bindgen_ty_1 = -223;
/// @see cv::Error::Code
pub type _bindgen_ty_1 = i32;
/// Random number generation
pub type CvRNG = uint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplImage {
    /// < sizeof(IplImage)
    pub nSize: ::std::os::raw::c_int,
    /// < version (=0)
    pub ID: ::std::os::raw::c_int,
    /// < Most of OpenCV functions support 1,2,3 or 4 channels
    pub nChannels: ::std::os::raw::c_int,
    /// < Ignored by OpenCV
    pub alphaChannel: ::std::os::raw::c_int,
    /// < Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,
    /// IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported.
    pub depth: ::std::os::raw::c_int,
    /// < Ignored by OpenCV
    pub colorModel: [::std::os::raw::c_char; 4usize],
    /// < ditto
    pub channelSeq: [::std::os::raw::c_char; 4usize],
    /// < 0 - interleaved color channels, 1 - separate color channels.
    /// cvCreateImage can only create interleaved images
    pub dataOrder: ::std::os::raw::c_int,
    /// < 0 - top-left origin,
    /// 1 - bottom-left origin (Windows bitmaps style).
    pub origin: ::std::os::raw::c_int,
    /// < Alignment of image rows (4 or 8).
    /// OpenCV ignores it and uses widthStep instead.
    pub align: ::std::os::raw::c_int,
    /// < Image width in pixels.
    pub width: ::std::os::raw::c_int,
    /// < Image height in pixels.
    pub height: ::std::os::raw::c_int,
    /// < Image ROI. If NULL, the whole image is selected.
    pub roi: *mut _IplROI,
    /// < Must be NULL.
    pub maskROI: *mut _IplImage,
    /// < "           "
    pub imageId: *mut ::std::os::raw::c_void,
    /// < "           "
    pub tileInfo: *mut _IplTileInfo,
    /// < Image data size in bytes
    /// (==image->height*image->widthStep
    /// in case of interleaved data)
    pub imageSize: ::std::os::raw::c_int,
    /// < Pointer to aligned image data.
    pub imageData: *mut ::std::os::raw::c_char,
    /// < Size of aligned image row in bytes.
    pub widthStep: ::std::os::raw::c_int,
    /// < Ignored by OpenCV.
    pub BorderMode: [::std::os::raw::c_int; 4usize],
    /// < Ditto.
    pub BorderConst: [::std::os::raw::c_int; 4usize],
    /// < Pointer to very origin of image data
    /// (not necessarily aligned) -
    /// needed for correct deallocation
    pub imageDataOrigin: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__IplImage() {
    assert_eq!(
        ::std::mem::size_of::<_IplImage>(),
        144usize,
        concat!("Size of: ", stringify!(_IplImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).nSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(nSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).ID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).nChannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(nChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).alphaChannel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(alphaChannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).colorModel as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(colorModel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).channelSeq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(channelSeq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).dataOrder as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(dataOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).origin as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).align as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).width as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).height as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).roi as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(roi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).maskROI as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(maskROI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).imageId as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).tileInfo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(tileInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).imageSize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).imageData as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).widthStep as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(widthStep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).BorderMode as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(BorderMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).BorderConst as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(BorderConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplImage>())).imageDataOrigin as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageDataOrigin)
        )
    );
}
pub type IplImage = _IplImage;
pub type IplTileInfo = _IplTileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplROI {
    /// < 0 - no COI (all channels are selected), 1 - 0th channel is selected ...
    pub coi: ::std::os::raw::c_int,
    pub xOffset: ::std::os::raw::c_int,
    pub yOffset: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IplROI() {
    assert_eq!(
        ::std::mem::size_of::<_IplROI>(),
        20usize,
        concat!("Size of: ", stringify!(_IplROI))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplROI>(),
        4usize,
        concat!("Alignment of ", stringify!(_IplROI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).coi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(coi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).xOffset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(xOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).yOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(yOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(height)
        )
    );
}
pub type IplROI = _IplROI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplConvKernel {
    pub nCols: ::std::os::raw::c_int,
    pub nRows: ::std::os::raw::c_int,
    pub anchorX: ::std::os::raw::c_int,
    pub anchorY: ::std::os::raw::c_int,
    pub values: *mut ::std::os::raw::c_int,
    pub nShiftR: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IplConvKernel() {
    assert_eq!(
        ::std::mem::size_of::<_IplConvKernel>(),
        32usize,
        concat!("Size of: ", stringify!(_IplConvKernel))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplConvKernel>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplConvKernel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).nCols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).nRows as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nRows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).anchorX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(anchorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).anchorY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(anchorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernel>())).nShiftR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nShiftR)
        )
    );
}
pub type IplConvKernel = _IplConvKernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplConvKernelFP {
    pub nCols: ::std::os::raw::c_int,
    pub nRows: ::std::os::raw::c_int,
    pub anchorX: ::std::os::raw::c_int,
    pub anchorY: ::std::os::raw::c_int,
    pub values: *mut f32,
}
#[test]
fn bindgen_test_layout__IplConvKernelFP() {
    assert_eq!(
        ::std::mem::size_of::<_IplConvKernelFP>(),
        24usize,
        concat!("Size of: ", stringify!(_IplConvKernelFP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplConvKernelFP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplConvKernelFP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernelFP>())).nCols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(nCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernelFP>())).nRows as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(nRows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernelFP>())).anchorX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(anchorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernelFP>())).anchorY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(anchorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplConvKernelFP>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(values)
        )
    );
}
pub type IplConvKernelFP = _IplConvKernelFP;
/// Matrix elements are stored row by row. Element (i, j) (i - 0-based row index, j - 0-based column
/// index) of a matrix can be retrieved or modified using CV_MAT_ELEM macro:
///
/// uchar pixval = CV_MAT_ELEM(grayimg, uchar, i, j)
/// CV_MAT_ELEM(cameraMatrix, float, 0, 2) = image.width*0.5f;
///
/// To access multiple-channel matrices, you can use
/// CV_MAT_ELEM(matrix, type, i, j\*nchannels + channel_idx).
///
/// @deprecated CvMat is now obsolete; consider using Mat instead.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvMat {
    pub type_: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub data: CvMat__bindgen_ty_1,
    pub rows: ::std::os::raw::c_int,
    pub cols: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvMat__bindgen_ty_1 {
    pub ptr: *mut uchar,
    pub s: *mut ::std::os::raw::c_short,
    pub i: *mut ::std::os::raw::c_int,
    pub fl: *mut f32,
    pub db: *mut f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CvMat__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvMat__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CvMat__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMat__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMat__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).db as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
}
#[test]
fn bindgen_test_layout_CvMat() {
    assert_eq!(
        ::std::mem::size_of::<CvMat>(),
        40usize,
        concat!("Size of: ", stringify!(CvMat))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMat>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).hdr_refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).rows as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).cols as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(cols)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvMatND {
    pub type_: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub data: CvMatND__bindgen_ty_1,
    pub dim: [CvMatND__bindgen_ty_2; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvMatND__bindgen_ty_1 {
    pub ptr: *mut uchar,
    pub fl: *mut f32,
    pub db: *mut f64,
    pub i: *mut ::std::os::raw::c_int,
    pub s: *mut ::std::os::raw::c_short,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CvMatND__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CvMatND__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMatND__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).db as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMatND__bindgen_ty_2 {
    pub size: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMatND__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(CvMatND__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(CvMatND__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_2>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND__bindgen_ty_2>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_2),
            "::",
            stringify!(step)
        )
    );
}
#[test]
fn bindgen_test_layout_CvMatND() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND>(),
        288usize,
        concat!("Size of: ", stringify!(CvMatND))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMatND))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).dims as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).hdr_refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).dim as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(dim)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseMat {
    pub type_: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub heap: *mut CvSet,
    pub hashtable: *mut *mut ::std::os::raw::c_void,
    pub hashsize: ::std::os::raw::c_int,
    pub valoffset: ::std::os::raw::c_int,
    pub idxoffset: ::std::os::raw::c_int,
    pub size: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CvSparseMat() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseMat>(),
        184usize,
        concat!("Size of: ", stringify!(CvSparseMat))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseMat>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseMat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).dims as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).hdr_refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).heap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).hashtable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).hashsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hashsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).valoffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(valoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).idxoffset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(idxoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMat>())).size as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(size)
        )
    );
}
/// iteration through a sparse array
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseNode {
    pub hashval: ::std::os::raw::c_uint,
    pub next: *mut CvSparseNode,
}
#[test]
fn bindgen_test_layout_CvSparseNode() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseNode>(),
        16usize,
        concat!("Size of: ", stringify!(CvSparseNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseNode>())).hashval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseNode),
            "::",
            stringify!(hashval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseMatIterator {
    pub mat: *mut CvSparseMat,
    pub node: *mut CvSparseNode,
    pub curidx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSparseMatIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseMatIterator>(),
        24usize,
        concat!("Size of: ", stringify!(CvSparseMatIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseMatIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseMatIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMatIterator>())).mat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(mat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMatIterator>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSparseMatIterator>())).curidx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(curidx)
        )
    );
}
/// \
/// Histogram                                      *
/// \
pub type CvHistType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvHistogram {
    pub type_: ::std::os::raw::c_int,
    pub bins: *mut CvArr,
    /// < For uniform histograms.
    pub thresh: [[f32; 2usize]; 32usize],
    /// < For non-uniform histograms.
    pub thresh2: *mut *mut f32,
    /// < Embedded matrix header for array histograms.
    pub mat: CvMatND,
}
#[test]
fn bindgen_test_layout_CvHistogram() {
    assert_eq!(
        ::std::mem::size_of::<CvHistogram>(),
        568usize,
        concat!("Size of: ", stringify!(CvHistogram))
    );
    assert_eq!(
        ::std::mem::align_of::<CvHistogram>(),
        8usize,
        concat!("Alignment of ", stringify!(CvHistogram))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvHistogram>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvHistogram>())).bins as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(bins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvHistogram>())).thresh as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvHistogram>())).thresh2 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(thresh2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvHistogram>())).mat as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(mat)
        )
    );
}
/// CvRect *****************************************/
/// /** @sa Rect_
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvRect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvRect() {
    assert_eq!(
        ::std::mem::size_of::<CvRect>(),
        16usize,
        concat!("Size of: ", stringify!(CvRect))
    );
    assert_eq!(
        ::std::mem::align_of::<CvRect>(),
        4usize,
        concat!("Alignment of ", stringify!(CvRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CvRect), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(CvRect), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvRect),
            "::",
            stringify!(height)
        )
    );
}
/// @sa TermCriteria
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTermCriteria {
    /// < may be combination of
    /// CV_TERMCRIT_ITER
    /// CV_TERMCRIT_EPS
    pub type_: ::std::os::raw::c_int,
    pub max_iter: ::std::os::raw::c_int,
    pub epsilon: f64,
}
#[test]
fn bindgen_test_layout_CvTermCriteria() {
    assert_eq!(
        ::std::mem::size_of::<CvTermCriteria>(),
        16usize,
        concat!("Size of: ", stringify!(CvTermCriteria))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTermCriteria>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTermCriteria))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTermCriteria>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTermCriteria>())).max_iter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(max_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTermCriteria>())).epsilon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(epsilon)
        )
    );
}
/// CvPoint and variants
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvPoint() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint>(),
        8usize,
        concat!("Size of: ", stringify!(CvPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint2D32f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CvPoint2D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint2D32f>(),
        8usize,
        concat!("Size of: ", stringify!(CvPoint2D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint2D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint2D32f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint2D32f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D32f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint2D32f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D32f),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint3D32f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_CvPoint3D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint3D32f>(),
        12usize,
        concat!("Size of: ", stringify!(CvPoint3D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint3D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint3D32f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D32f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D32f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D32f>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint2D64f {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_CvPoint2D64f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint2D64f>(),
        16usize,
        concat!("Size of: ", stringify!(CvPoint2D64f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint2D64f>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPoint2D64f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint2D64f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D64f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint2D64f>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D64f),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint3D64f {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_CvPoint3D64f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint3D64f>(),
        24usize,
        concat!("Size of: ", stringify!(CvPoint3D64f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint3D64f>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPoint3D64f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D64f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D64f>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint3D64f>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(z)
        )
    );
}
/// CvSize's & CvBox
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSize {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSize() {
    assert_eq!(
        ::std::mem::size_of::<CvSize>(),
        8usize,
        concat!("Size of: ", stringify!(CvSize))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSize>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSize>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSize>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSize2D32f {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_CvSize2D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvSize2D32f>(),
        8usize,
        concat!("Size of: ", stringify!(CvSize2D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSize2D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSize2D32f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSize2D32f>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize2D32f),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSize2D32f>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize2D32f),
            "::",
            stringify!(height)
        )
    );
}
/// @sa RotatedRect
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvBox2D {
    /// < Center of the box.
    pub center: CvPoint2D32f,
    /// < Box width and length.
    pub size: CvSize2D32f,
    /// < Angle between the horizontal axis           */
    /// /**< and the first side (i.e. length) in degrees
    pub angle: f32,
}
#[test]
fn bindgen_test_layout_CvBox2D() {
    assert_eq!(
        ::std::mem::size_of::<CvBox2D>(),
        20usize,
        concat!("Size of: ", stringify!(CvBox2D))
    );
    assert_eq!(
        ::std::mem::align_of::<CvBox2D>(),
        4usize,
        concat!("Alignment of ", stringify!(CvBox2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvBox2D>())).center as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvBox2D>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvBox2D>())).angle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(angle)
        )
    );
}
/// Line iterator state:
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvLineIterator {
    /// Pointer to the current point:
    pub ptr: *mut uchar,
    pub err: ::std::os::raw::c_int,
    pub plus_delta: ::std::os::raw::c_int,
    pub minus_delta: ::std::os::raw::c_int,
    pub plus_step: ::std::os::raw::c_int,
    pub minus_step: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvLineIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvLineIterator>(),
        32usize,
        concat!("Size of: ", stringify!(CvLineIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvLineIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvLineIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).err as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).plus_delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(plus_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).minus_delta as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(minus_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).plus_step as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(plus_step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvLineIterator>())).minus_step as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(minus_step)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSlice {
    pub start_index: ::std::os::raw::c_int,
    pub end_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSlice() {
    assert_eq!(
        ::std::mem::size_of::<CvSlice>(),
        8usize,
        concat!("Size of: ", stringify!(CvSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSlice>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSlice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSlice>())).start_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSlice),
            "::",
            stringify!(start_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSlice>())).end_index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSlice),
            "::",
            stringify!(end_index)
        )
    );
}
/// CvScalar *****************************************/
/// /** @sa Scalar_
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvScalar {
    pub val: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_CvScalar() {
    assert_eq!(
        ::std::mem::size_of::<CvScalar>(),
        32usize,
        concat!("Size of: ", stringify!(CvScalar))
    );
    assert_eq!(
        ::std::mem::align_of::<CvScalar>(),
        8usize,
        concat!("Alignment of ", stringify!(CvScalar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvScalar>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvScalar),
            "::",
            stringify!(val)
        )
    );
}
/// Memory storage
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemBlock {
    pub prev: *mut CvMemBlock,
    pub next: *mut CvMemBlock,
}
#[test]
fn bindgen_test_layout_CvMemBlock() {
    assert_eq!(
        ::std::mem::size_of::<CvMemBlock>(),
        16usize,
        concat!("Size of: ", stringify!(CvMemBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemBlock>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemBlock>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemBlock),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemStorage {
    pub signature: ::std::os::raw::c_int,
    /// < First allocated block.
    pub bottom: *mut CvMemBlock,
    /// < Current memory block - top of the stack.
    pub top: *mut CvMemBlock,
    /// < We get new blocks from parent as needed.
    pub parent: *mut CvMemStorage,
    /// < Block size.
    pub block_size: ::std::os::raw::c_int,
    /// < Remaining free space in current block.
    pub free_space: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMemStorage() {
    assert_eq!(
        ::std::mem::size_of::<CvMemStorage>(),
        40usize,
        concat!("Size of: ", stringify!(CvMemStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemStorage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).bottom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).top as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).block_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStorage>())).free_space as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(free_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemStoragePos {
    pub top: *mut CvMemBlock,
    pub free_space: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMemStoragePos() {
    assert_eq!(
        ::std::mem::size_of::<CvMemStoragePos>(),
        16usize,
        concat!("Size of: ", stringify!(CvMemStoragePos))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemStoragePos>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemStoragePos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStoragePos>())).top as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStoragePos),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMemStoragePos>())).free_space as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStoragePos),
            "::",
            stringify!(free_space)
        )
    );
}
/// Sequence
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqBlock {
    /// < Previous sequence block.
    pub prev: *mut CvSeqBlock,
    /// < Next sequence block.
    pub next: *mut CvSeqBlock,
    /// < Index of the first element in the block +  */
    /// /**< sequence->first->start_index.
    pub start_index: ::std::os::raw::c_int,
    /// < Number of elements in the block.
    pub count: ::std::os::raw::c_int,
    /// < Pointer to the first element of the block.
    pub data: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqBlock() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqBlock>(),
        32usize,
        concat!("Size of: ", stringify!(CvSeqBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqBlock>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqBlock>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqBlock>())).start_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(start_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqBlock>())).count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqBlock>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeq {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
}
#[test]
fn bindgen_test_layout_CvSeq() {
    assert_eq!(
        ::std::mem::size_of::<CvSeq>(),
        96usize,
        concat!("Size of: ", stringify!(CvSeq))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeq>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).h_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).h_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).v_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).v_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).elem_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).block_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).delta_elems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).storage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).free_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSetElem {
    pub flags: ::std::os::raw::c_int,
    pub next_free: *mut CvSetElem,
}
#[test]
fn bindgen_test_layout_CvSetElem() {
    assert_eq!(
        ::std::mem::size_of::<CvSetElem>(),
        16usize,
        concat!("Size of: ", stringify!(CvSetElem))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSetElem>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSetElem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSetElem>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSetElem),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSetElem>())).next_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSetElem),
            "::",
            stringify!(next_free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSet {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub free_elems: *mut CvSetElem,
    pub active_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSet() {
    assert_eq!(
        ::std::mem::size_of::<CvSet>(),
        112usize,
        concat!("Size of: ", stringify!(CvSet))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSet>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).h_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).h_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).v_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).v_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).elem_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).block_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).delta_elems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).storage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).free_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).free_elems as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(free_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).active_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(active_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphEdge {
    pub flags: ::std::os::raw::c_int,
    pub weight: f32,
    pub next: [*mut CvGraphEdge; 2usize],
    pub vtx: [*mut CvGraphVtx; 2usize],
}
#[test]
fn bindgen_test_layout_CvGraphEdge() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphEdge>(),
        40usize,
        concat!("Size of: ", stringify!(CvGraphEdge))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphEdge>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphEdge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphEdge>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphEdge>())).weight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphEdge>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphEdge>())).vtx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(vtx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphVtx {
    pub flags: ::std::os::raw::c_int,
    pub first: *mut CvGraphEdge,
}
#[test]
fn bindgen_test_layout_CvGraphVtx() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphVtx>(),
        16usize,
        concat!("Size of: ", stringify!(CvGraphVtx))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphVtx>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphVtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphVtx>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphVtx>())).first as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphVtx2D {
    pub flags: ::std::os::raw::c_int,
    pub first: *mut CvGraphEdge,
    pub ptr: *mut CvPoint2D32f,
}
#[test]
fn bindgen_test_layout_CvGraphVtx2D() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphVtx2D>(),
        24usize,
        concat!("Size of: ", stringify!(CvGraphVtx2D))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphVtx2D>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphVtx2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphVtx2D>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphVtx2D>())).first as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphVtx2D>())).ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraph {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub free_elems: *mut CvSetElem,
    pub active_count: ::std::os::raw::c_int,
    pub edges: *mut CvSet,
}
#[test]
fn bindgen_test_layout_CvGraph() {
    assert_eq!(
        ::std::mem::size_of::<CvGraph>(),
        120usize,
        concat!("Size of: ", stringify!(CvGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).h_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).h_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).v_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).v_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).elem_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).block_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).delta_elems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).storage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).free_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).free_elems as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(free_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).active_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(active_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).edges as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(edges)
        )
    );
}
/// Chain/Countour
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvChain {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub origin: CvPoint,
}
#[test]
fn bindgen_test_layout_CvChain() {
    assert_eq!(
        ::std::mem::size_of::<CvChain>(),
        104usize,
        concat!("Size of: ", stringify!(CvChain))
    );
    assert_eq!(
        ::std::mem::align_of::<CvChain>(),
        8usize,
        concat!("Alignment of ", stringify!(CvChain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).h_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).h_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).v_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).v_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).elem_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).block_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).delta_elems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).storage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).free_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).origin as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvContour {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub rect: CvRect,
    pub color: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_CvContour() {
    assert_eq!(
        ::std::mem::size_of::<CvContour>(),
        128usize,
        concat!("Size of: ", stringify!(CvContour))
    );
    assert_eq!(
        ::std::mem::align_of::<CvContour>(),
        8usize,
        concat!("Alignment of ", stringify!(CvContour))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).h_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).h_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).v_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).v_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).elem_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).block_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).delta_elems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).storage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).free_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).rect as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).color as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvContour>())).reserved as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CvPoint2DSeq = CvContour;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqWriter {
    pub header_size: ::std::os::raw::c_int,
    pub seq: *mut CvSeq,
    pub block: *mut CvSeqBlock,
    pub ptr: *mut schar,
    pub block_min: *mut schar,
    pub block_max: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqWriter() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqWriter>(),
        48usize,
        concat!("Size of: ", stringify!(CvSeqWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqWriter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).header_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).block_min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqWriter>())).block_max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqReader {
    pub header_size: ::std::os::raw::c_int,
    pub seq: *mut CvSeq,
    pub block: *mut CvSeqBlock,
    pub ptr: *mut schar,
    pub block_min: *mut schar,
    pub block_max: *mut schar,
    pub delta_index: ::std::os::raw::c_int,
    pub prev_elem: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqReader() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqReader>(),
        64usize,
        concat!("Size of: ", stringify!(CvSeqReader))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqReader>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqReader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).header_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).block_min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).block_max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).delta_index as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(delta_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeqReader>())).prev_elem as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(prev_elem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvFileStorage {
    _unused: [u8; 0],
}
/// @brief List of attributes. :
///
/// In the current implementation, attributes are used to pass extra parameters when writing user
/// objects (see cvWrite). XML attributes inside tags are not supported, aside from the object type
/// specification (type_id attribute).
/// @see cvAttrList, cvAttrValue
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvAttrList {
    /// < NULL-terminated array of (attribute_name,attribute_value) pairs.
    pub attr: *mut *const ::std::os::raw::c_char,
    /// < Pointer to next chunk of the attributes list.
    pub next: *mut CvAttrList,
}
#[test]
fn bindgen_test_layout_CvAttrList() {
    assert_eq!(
        ::std::mem::size_of::<CvAttrList>(),
        16usize,
        concat!("Size of: ", stringify!(CvAttrList))
    );
    assert_eq!(
        ::std::mem::align_of::<CvAttrList>(),
        8usize,
        concat!("Alignment of ", stringify!(CvAttrList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvAttrList>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvAttrList),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvAttrList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvAttrList),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvString {
    pub len: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CvString() {
    assert_eq!(
        ::std::mem::size_of::<CvString>(),
        16usize,
        concat!("Size of: ", stringify!(CvString))
    );
    assert_eq!(
        ::std::mem::align_of::<CvString>(),
        8usize,
        concat!("Alignment of ", stringify!(CvString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvString>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvString>())).ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvString),
            "::",
            stringify!(ptr)
        )
    );
}
/// All the keys (names) of elements in the readed file storage
/// are stored in the hash to speed up the lookup operations:
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvStringHashNode {
    pub hashval: ::std::os::raw::c_uint,
    pub str: CvString,
    pub next: *mut CvStringHashNode,
}
#[test]
fn bindgen_test_layout_CvStringHashNode() {
    assert_eq!(
        ::std::mem::size_of::<CvStringHashNode>(),
        32usize,
        concat!("Size of: ", stringify!(CvStringHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvStringHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvStringHashNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvStringHashNode>())).hashval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(hashval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvStringHashNode>())).str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvStringHashNode>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGenericHash {
    _unused: [u8; 0],
}
pub type CvFileNodeHash = CvGenericHash;
/// Basic element of the file storage - scalar or collection:
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvFileNode {
    pub tag: ::std::os::raw::c_int,
    /// < type information
    /// (only for user-defined object, for others it is 0)
    pub info: *mut CvTypeInfo,
    pub data: CvFileNode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvFileNode__bindgen_ty_1 {
    /// < scalar floating-point number
    pub f: f64,
    /// < scalar integer number
    pub i: ::std::os::raw::c_int,
    /// < text string
    pub str: CvString,
    /// < sequence (ordered collection of file nodes)
    pub seq: *mut CvSeq,
    /// < map (collection of named file nodes)
    pub map: *mut CvFileNodeHash,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_CvFileNode__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvFileNode__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CvFileNode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvFileNode__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvFileNode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
}
#[test]
fn bindgen_test_layout_CvFileNode() {
    assert_eq!(
        ::std::mem::size_of::<CvFileNode>(),
        32usize,
        concat!("Size of: ", stringify!(CvFileNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvFileNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvFileNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFileNode>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(data)
        )
    );
}
pub type CvIsInstanceFunc =
    ::std::option::Option<unsafe extern "C" fn(struct_ptr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
pub type CvReleaseFunc = ::std::option::Option<unsafe extern "C" fn(struct_dblptr: *mut *mut ::std::os::raw::c_void)>;
pub type CvReadFunc = ::std::option::Option<
    unsafe extern "C" fn(storage: *mut CvFileStorage, node: *mut CvFileNode) -> *mut ::std::os::raw::c_void,
>;
pub type CvWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        storage: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        struct_ptr: *const ::std::os::raw::c_void,
        attributes: CvAttrList,
    ),
>;
pub type CvCloneFunc = ::std::option::Option<
    unsafe extern "C" fn(struct_ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
/// @brief Type information
///
/// The structure contains information about one of the standard or user-defined types. Instances of the
/// type may or may not contain a pointer to the corresponding CvTypeInfo structure. In any case, there
/// is a way to find the type info structure for a given object using the cvTypeOf function.
/// Alternatively, type info can be found by type name using cvFindType, which is used when an object
/// is read from file storage. The user can register a new type with cvRegisterType that adds the type
/// information structure into the beginning of the type list. Thus, it is possible to create
/// specialized types from generic standard types and override the basic methods.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTypeInfo {
    /// < not used
    pub flags: ::std::os::raw::c_int,
    /// < sizeof(CvTypeInfo)
    pub header_size: ::std::os::raw::c_int,
    /// < previous registered type in the list
    pub prev: *mut CvTypeInfo,
    /// < next registered type in the list
    pub next: *mut CvTypeInfo,
    /// < type name, written to file storage
    pub type_name: *const ::std::os::raw::c_char,
    /// < checks if the passed object belongs to the type
    pub is_instance: CvIsInstanceFunc,
    /// < releases object (memory etc.)
    pub release: CvReleaseFunc,
    /// < reads object from file storage
    pub read: CvReadFunc,
    /// < writes object to file storage
    pub write: CvWriteFunc,
    /// < creates a copy of the object
    pub clone: CvCloneFunc,
}
#[test]
fn bindgen_test_layout_CvTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(CvTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).type_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).is_instance as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(is_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).release as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).read as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).write as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTypeInfo>())).clone as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(clone)
        )
    );
}
/// System data types
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPluginFuncInfo {
    pub func_addr: *mut *mut ::std::os::raw::c_void,
    pub default_func_addr: *mut ::std::os::raw::c_void,
    pub func_names: *const ::std::os::raw::c_char,
    pub search_modules: ::std::os::raw::c_int,
    pub loaded_from: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvPluginFuncInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvPluginFuncInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CvPluginFuncInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPluginFuncInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPluginFuncInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPluginFuncInfo>())).func_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(func_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPluginFuncInfo>())).default_func_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(default_func_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPluginFuncInfo>())).func_names as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(func_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPluginFuncInfo>())).search_modules as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(search_modules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPluginFuncInfo>())).loaded_from as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(loaded_from)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvModuleInfo {
    pub next: *mut CvModuleInfo,
    pub name: *const ::std::os::raw::c_char,
    pub version: *const ::std::os::raw::c_char,
    pub func_tab: *mut CvPluginFuncInfo,
}
#[test]
fn bindgen_test_layout_CvModuleInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvModuleInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CvModuleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvModuleInfo>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvModuleInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvModuleInfo>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvModuleInfo>())).func_tab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(func_tab)
        )
    );
}
extern "C" {
    /// `malloc` wrapper.
    /// If there is no enough memory, the function
    /// (as well as other OpenCV functions that call cvAlloc)
    /// raises an error.
    pub fn cvAlloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// `free` wrapper.
    /// Here and further all the memory releasing functions
    /// (that all call cvFree) take double pointer in order to
    /// to clear pointer to the data after releasing it.
    /// Passing pointer to NULL pointer is Ok: nothing happens in this case
    pub fn cvFree_(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Creates an image header but does not allocate the image data.
    ///
    /// @param size Image width and height
    /// @param depth Image depth (see cvCreateImage )
    /// @param channels Number of channels (see cvCreateImage )
    pub fn cvCreateImageHeader(
        size: CvSize,
        depth: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    ) -> *mut IplImage;
}
extern "C" {
    /// @brief Initializes an image header that was previously allocated.
    ///
    /// The returned IplImage\* points to the initialized header.
    /// @param image Image header to initialize
    /// @param size Image width and height
    /// @param depth Image depth (see cvCreateImage )
    /// @param channels Number of channels (see cvCreateImage )
    /// @param origin Top-left IPL_ORIGIN_TL or bottom-left IPL_ORIGIN_BL
    /// @param align Alignment for image rows, typically 4 or 8 bytes
    pub fn cvInitImageHeader(
        image: *mut IplImage,
        size: CvSize,
        depth: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> *mut IplImage;
}
extern "C" {
    /// @brief Creates an image header and allocates the image data.
    ///
    /// This function call is equivalent to the following code:
    /// @code
    /// header = cvCreateImageHeader(size, depth, channels);
    /// cvCreateData(header);
    /// @endcode
    /// @param size Image width and height
    /// @param depth Bit depth of image elements. See IplImage for valid depths.
    /// @param channels Number of channels per pixel. See IplImage for details. This function only creates
    /// images with interleaved channels.
    pub fn cvCreateImage(size: CvSize, depth: ::std::os::raw::c_int, channels: ::std::os::raw::c_int) -> *mut IplImage;
}
extern "C" {
    /// @brief Deallocates an image header.
    ///
    /// This call is an analogue of :
    /// @code
    /// if(image )
    /// {
    /// iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);
    /// image = 0;
    /// }
    /// @endcode
    /// but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro).
    /// @param image Double pointer to the image header
    pub fn cvReleaseImageHeader(image: *mut *mut IplImage);
}
extern "C" {
    /// @brief Deallocates the image header and the image data.
    ///
    /// This call is a shortened form of :
    /// @code
    /// if(*image )
    /// {
    /// cvReleaseData(*image);
    /// cvReleaseImageHeader(image);
    /// }
    /// @endcode
    /// @param image Double pointer to the image header
    pub fn cvReleaseImage(image: *mut *mut IplImage);
}
extern "C" {
    /// Creates a copy of IPL image (widthStep may differ)
    pub fn cvCloneImage(image: *const IplImage) -> *mut IplImage;
}
extern "C" {
    /// @brief Sets the channel of interest in an IplImage.
    ///
    /// If the ROI is set to NULL and the coi is *not* 0, the ROI is allocated. Most OpenCV functions do
    /// not* support the COI setting, so to process an individual image/matrix channel one may copy (via
    /// cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result
    /// back (via cvCopy or cvMerge) if needed.
    /// @param image A pointer to the image header
    /// @param coi The channel of interest. 0 - all channels are selected, 1 - first channel is selected,
    /// etc. Note that the channel indices become 1-based.
    pub fn cvSetImageCOI(image: *mut IplImage, coi: ::std::os::raw::c_int);
}
extern "C" {
    /// @brief Returns the index of the channel of interest.
    ///
    /// Returns the channel of interest of in an IplImage. Returned values correspond to the coi in
    /// cvSetImageCOI.
    /// @param image A pointer to the image header
    pub fn cvGetImageCOI(image: *const IplImage) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Sets an image Region Of Interest (ROI) for a given rectangle.
    ///
    /// If the original image ROI was NULL and the rect is not the whole image, the ROI structure is
    /// allocated.
    ///
    /// Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For
    /// example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the
    /// ROI, not the original image.
    /// @param image A pointer to the image header
    /// @param rect The ROI rectangle
    pub fn cvSetImageROI(image: *mut IplImage, rect: CvRect);
}
extern "C" {
    /// @brief Resets the image ROI to include the entire image and releases the ROI structure.
    ///
    /// This produces a similar result to the following, but in addition it releases the ROI structure. :
    /// @code
    /// cvSetImageROI(image, cvRect(0, 0, image->width, image->height ));
    /// cvSetImageCOI(image, 0);
    /// @endcode
    /// @param image A pointer to the image header
    pub fn cvResetImageROI(image: *mut IplImage);
}
extern "C" {
    /// @brief Returns the image ROI.
    ///
    /// If there is no ROI set, cvRect(0,0,image-\>width,image-\>height) is returned.
    /// @param image A pointer to the image header
    pub fn cvGetImageROI(image: *const IplImage) -> CvRect;
}
extern "C" {
    /// @brief Creates a matrix header but does not allocate the matrix data.
    ///
    /// The function allocates a new matrix header and returns a pointer to it. The matrix data can then be
    /// allocated using cvCreateData or set explicitly to user-allocated data via cvSetData.
    /// @param rows Number of rows in the matrix
    /// @param cols Number of columns in the matrix
    /// @param type Type of the matrix elements, see cvCreateMat
    pub fn cvCreateMatHeader(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Initializes a pre-allocated matrix header.
    ///
    /// This function is often used to process raw data with OpenCV matrix functions. For example, the
    /// following code computes the matrix product of two matrices, stored as ordinary arrays:
    /// @code
    /// double a[] = { 1, 2, 3, 4,
    /// 5, 6, 7, 8,
    /// 9, 10, 11, 12 };
    ///
    /// double b[] = { 1, 5, 9,
    /// 2, 6, 10,
    /// 3, 7, 11,
    /// 4, 8, 12 };
    ///
    /// double c[9];
    /// CvMat Ma, Mb, Mc ;
    ///
    /// cvInitMatHeader(&Ma, 3, 4, CV_64FC1, a);
    /// cvInitMatHeader(&Mb, 4, 3, CV_64FC1, b);
    /// cvInitMatHeader(&Mc, 3, 3, CV_64FC1, c);
    ///
    /// cvMatMulAdd(&Ma, &Mb, 0, &Mc);
    /// // the c array now contains the product of a (3x4) and b (4x3)
    /// @endcode
    /// @param mat A pointer to the matrix header to be initialized
    /// @param rows Number of rows in the matrix
    /// @param cols Number of columns in the matrix
    /// @param type Type of the matrix elements, see cvCreateMat .
    /// @param data Optional: data pointer assigned to the matrix header
    /// @param step Optional: full row width in bytes of the assigned data. By default, the minimal
    /// possible step is used which assumes there are no gaps between subsequent rows of the matrix.
    pub fn cvInitMatHeader(
        mat: *mut CvMat,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Creates a matrix header and allocates the matrix data.
    ///
    /// The function call is equivalent to the following code:
    /// @code
    /// CvMat* mat = cvCreateMatHeader(rows, cols, type);
    /// cvCreateData(mat);
    /// @endcode
    /// @param rows Number of rows in the matrix
    /// @param cols Number of columns in the matrix
    /// @param type The type of the matrix elements in the form
    /// CV_\<bit depth\>\<S|U|F\>C\<number of channels\> , where S=signed, U=unsigned, F=float. For
    /// example, CV _ 8UC1 means the elements are 8-bit unsigned and the there is 1 channel, and CV _
    /// 32SC2 means the elements are 32-bit signed and there are 2 channels.
    pub fn cvCreateMat(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Deallocates a matrix.
    ///
    /// The function decrements the matrix data reference counter and deallocates matrix header. If the data
    /// reference counter is 0, it also deallocates the data. :
    /// @code
    /// if(*mat )
    /// cvDecRefData(*mat);
    /// cvFree((void**)mat);
    /// @endcode
    /// @param mat Double pointer to the matrix
    pub fn cvReleaseMat(mat: *mut *mut CvMat);
}
extern "C" {
    /// Creates an exact copy of the input matrix (except, may be, step value)
    pub fn cvCloneMat(mat: *const CvMat) -> *mut CvMat;
}
extern "C" {
    /// @brief Returns matrix header corresponding to the rectangular sub-array of input image or matrix.
    ///
    /// The function returns header, corresponding to a specified rectangle of the input array. In other
    ///
    /// words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is
    /// taken into account by the function so the sub-array of ROI is actually extracted.
    /// @param arr Input array
    /// @param submat Pointer to the resultant sub-array header
    /// @param rect Zero-based coordinates of the rectangle of interest
    pub fn cvGetSubRect(arr: *const CvArr, submat: *mut CvMat, rect: CvRect) -> *mut CvMat;
}
extern "C" {
    /// @brief Returns array row or row span.
    ///
    /// The function returns the header, corresponding to a specified row/row span of the input array.
    /// cvGetRow(arr, submat, row) is a shortcut for cvGetRows(arr, submat, row, row+1).
    /// @param arr Input array
    /// @param submat Pointer to the resulting sub-array header
    /// @param start_row Zero-based index of the starting row (inclusive) of the span
    /// @param end_row Zero-based index of the ending row (exclusive) of the span
    /// @param delta_row Index step in the row span. That is, the function extracts every delta_row -th
    /// row from start_row and up to (but not including) end_row .
    pub fn cvGetRows(
        arr: *const CvArr,
        submat: *mut CvMat,
        start_row: ::std::os::raw::c_int,
        end_row: ::std::os::raw::c_int,
        delta_row: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Returns one of more array columns.
    ///
    /// The function returns the header, corresponding to a specified column span of the input array. That
    ///
    /// is, no data is copied. Therefore, any modifications of the submatrix will affect the original array.
    /// If you need to copy the columns, use cvCloneMat. cvGetCol(arr, submat, col) is a shortcut for
    /// cvGetCols(arr, submat, col, col+1).
    /// @param arr Input array
    /// @param submat Pointer to the resulting sub-array header
    /// @param start_col Zero-based index of the starting column (inclusive) of the span
    /// @param end_col Zero-based index of the ending column (exclusive) of the span
    pub fn cvGetCols(
        arr: *const CvArr,
        submat: *mut CvMat,
        start_col: ::std::os::raw::c_int,
        end_col: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Returns one of array diagonals.
    ///
    /// The function returns the header, corresponding to a specified diagonal of the input array.
    /// @param arr Input array
    /// @param submat Pointer to the resulting sub-array header
    /// @param diag Index of the array diagonal. Zero value corresponds to the main diagonal, -1
    /// corresponds to the diagonal above the main, 1 corresponds to the diagonal below the main, and so
    /// forth.
    pub fn cvGetDiag(arr: *const CvArr, submat: *mut CvMat, diag: ::std::os::raw::c_int) -> *mut CvMat;
}
extern "C" {
    /// low-level scalar <-> raw data conversion functions
    pub fn cvScalarToRawData(
        scalar: *const CvScalar,
        data: *mut ::std::os::raw::c_void,
        type_: ::std::os::raw::c_int,
        extend_to_12: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvRawDataToScalar(data: *const ::std::os::raw::c_void, type_: ::std::os::raw::c_int, scalar: *mut CvScalar);
}
extern "C" {
    /// @brief Creates a new matrix header but does not allocate the matrix data.
    ///
    /// The function allocates a header for a multi-dimensional dense array. The array data can further be
    /// allocated using cvCreateData or set explicitly to user-allocated data via cvSetData.
    /// @param dims Number of array dimensions
    /// @param sizes Array of dimension sizes
    /// @param type Type of array elements, see cvCreateMat
    pub fn cvCreateMatNDHeader(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMatND;
}
extern "C" {
    /// @brief Creates the header and allocates the data for a multi-dimensional dense array.
    ///
    /// This function call is equivalent to the following code:
    /// @code
    /// CvMatND* mat = cvCreateMatNDHeader(dims, sizes, type);
    /// cvCreateData(mat);
    /// @endcode
    /// @param dims Number of array dimensions. This must not exceed CV_MAX_DIM (32 by default, but can be
    /// changed at build time).
    /// @param sizes Array of dimension sizes.
    /// @param type Type of array elements, see cvCreateMat .
    pub fn cvCreateMatND(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMatND;
}
extern "C" {
    /// @brief Initializes a pre-allocated multi-dimensional array header.
    ///
    /// @param mat A pointer to the array header to be initialized
    /// @param dims The number of array dimensions
    /// @param sizes An array of dimension sizes
    /// @param type Type of array elements, see cvCreateMat
    /// @param data Optional data pointer assigned to the matrix header
    pub fn cvInitMatNDHeader(
        mat: *mut CvMatND,
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut CvMatND;
}
extern "C" {
    /// Creates a copy of CvMatND (except, may be, steps)
    pub fn cvCloneMatND(mat: *const CvMatND) -> *mut CvMatND;
}
extern "C" {
    /// @brief Creates sparse array.
    ///
    /// The function allocates a multi-dimensional sparse array. Initially the array contain no elements,
    /// that is PtrND and other related functions will return 0 for every index.
    /// @param dims Number of array dimensions. In contrast to the dense matrix, the number of dimensions is
    /// practically unlimited (up to \f$2^{16}\f$ ).
    /// @param sizes Array of dimension sizes
    /// @param type Type of array elements. The same as for CvMat
    pub fn cvCreateSparseMat(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvSparseMat;
}
extern "C" {
    /// @brief Deallocates sparse array.
    ///
    /// The function releases the sparse array and clears the array pointer upon exit.
    /// @param mat Double pointer to the array
    pub fn cvReleaseSparseMat(mat: *mut *mut CvSparseMat);
}
extern "C" {
    /// Creates a copy of CvSparseMat (except, may be, zero items)
    pub fn cvCloneSparseMat(mat: *const CvSparseMat) -> *mut CvSparseMat;
}
extern "C" {
    /// @brief Initializes sparse array elements iterator.
    ///
    /// The function initializes iterator of sparse array elements and returns pointer to the first element,
    /// or NULL if the array is empty.
    /// @param mat Input array
    /// @param mat_iterator Initialized iterator
    pub fn cvInitSparseMatIterator(
        mat: *const CvSparseMat,
        mat_iterator: *mut CvSparseMatIterator,
    ) -> *mut CvSparseNode;
}
/// matrix iterator: used for n-ary operations on dense arrays
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvNArrayIterator {
    /// < number of arrays
    pub count: ::std::os::raw::c_int,
    /// < number of dimensions to iterate
    pub dims: ::std::os::raw::c_int,
    /// < maximal common linear size: { width = size, height = 1 }
    pub size: CvSize,
    /// < pointers to the array slices
    pub ptr: [*mut uchar; 10usize],
    /// < for internal use
    pub stack: [::std::os::raw::c_int; 32usize],
    /// < pointers to the headers of the
    /// matrices that are processed
    pub hdr: [*mut CvMatND; 10usize],
}
#[test]
fn bindgen_test_layout_CvNArrayIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvNArrayIterator>(),
        304usize,
        concat!("Size of: ", stringify!(CvNArrayIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvNArrayIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvNArrayIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).dims as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).stack as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvNArrayIterator>())).hdr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    /// initializes iterator that traverses through several arrays simulteneously
    /// (the function together with cvNextArraySlice is used for
    /// N-ari element-wise operations)
    pub fn cvInitNArrayIterator(
        count: ::std::os::raw::c_int,
        arrs: *mut *mut CvArr,
        mask: *const CvArr,
        stubs: *mut CvMatND,
        array_iterator: *mut CvNArrayIterator,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// returns zero value if iteration is finished, non-zero (slice length) otherwise
    pub fn cvNextNArraySlice(array_iterator: *mut CvNArrayIterator) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns type of array elements.
    ///
    /// The function returns type of the array elements. In the case of IplImage the type is converted to
    /// CvMat-like representation. For example, if the image has been created as:
    /// @code
    /// IplImage* img = cvCreateImage(cvSize(640, 480), IPL_DEPTH_8U, 3);
    /// @endcode
    /// The code cvGetElemType(img) will return CV_8UC3.
    /// @param arr Input array
    pub fn cvGetElemType(arr: *const CvArr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Return number of array dimensions
    ///
    /// The function returns the array dimensionality and the array of dimension sizes. In the case of
    /// IplImage or CvMat it always returns 2 regardless of number of image/matrix rows. For example, the
    /// following code calculates total number of array elements:
    /// @code
    /// int sizes[CV_MAX_DIM];
    /// int i, total = 1;
    /// int dims = cvGetDims(arr, size);
    /// for(i = 0; i < dims; i++ )
    /// total *= sizes[i];
    /// @endcode
    /// @param arr Input array
    /// @param sizes Optional output vector of the array dimension sizes. For 2d arrays the number of rows
    /// (height) goes first, number of columns (width) next.
    pub fn cvGetDims(arr: *const CvArr, sizes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns array size along the specified dimension.
    ///
    /// @param arr Input array
    /// @param index Zero-based dimension index (for matrices 0 means number of rows, 1 means number of
    /// columns; for images 0 means height, 1 means width)
    pub fn cvGetDimSize(arr: *const CvArr, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Return pointer to a particular array element.
    ///
    /// The functions return a pointer to a specific array element. Number of array dimension should match
    /// to the number of indices passed to the function except for cvPtr1D function that can be used for
    /// sequential access to 1D, 2D or nD dense arrays.
    ///
    /// The functions can be used for sparse arrays as well - if the requested node does not exist they
    /// create it and set it to zero.
    ///
    /// All these as well as other functions accessing array elements ( cvGetND , cvGetRealND , cvSet
    /// , cvSetND , cvSetRealND ) raise an error in case if the element index is out of range.
    /// @param arr Input array
    /// @param idx0 The first zero-based component of the element index
    /// @param type Optional output parameter: type of matrix elements
    pub fn cvPtr1D(arr: *const CvArr, idx0: ::std::os::raw::c_int, type_: *mut ::std::os::raw::c_int) -> *mut uchar;
}
extern "C" {
    /// @overload
    pub fn cvPtr2D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut uchar;
}
extern "C" {
    /// @overload
    pub fn cvPtr3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut uchar;
}
extern "C" {
    /// @overload
    /// @param arr Input array
    /// @param idx Array of the element indices
    /// @param type Optional output parameter: type of matrix elements
    /// @param create_node Optional input parameter for sparse matrices. Non-zero value of the parameter
    /// means that the requested element is created if it does not exist already.
    /// @param precalc_hashval Optional input parameter for sparse matrices. If the pointer is not NULL,
    /// the function does not recalculate the node hash value, but takes it from the specified location.
    /// It is useful for speeding up pair-wise operations (TODO: provide an example)
    pub fn cvPtrND(
        arr: *const CvArr,
        idx: *const ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
        create_node: ::std::os::raw::c_int,
        precalc_hashval: *mut ::std::os::raw::c_uint,
    ) -> *mut uchar;
}
extern "C" {
    /// @brief Return a specific array element.
    ///
    /// The functions return a specific array element. In the case of a sparse array the functions return 0
    /// if the requested node does not exist (no new node is created by the functions).
    /// @param arr Input array
    /// @param idx0 The first zero-based component of the element index
    pub fn cvGet1D(arr: *const CvArr, idx0: ::std::os::raw::c_int) -> CvScalar;
}
extern "C" {
    /// @overload
    pub fn cvGet2D(arr: *const CvArr, idx0: ::std::os::raw::c_int, idx1: ::std::os::raw::c_int) -> CvScalar;
}
extern "C" {
    /// @overload
    pub fn cvGet3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> CvScalar;
}
extern "C" {
    /// @overload
    /// @param arr Input array
    /// @param idx Array of the element indices
    pub fn cvGetND(arr: *const CvArr, idx: *const ::std::os::raw::c_int) -> CvScalar;
}
extern "C" {
    /// @brief Return a specific element of single-channel 1D, 2D, 3D or nD array.
    ///
    /// Returns a specific element of a single-channel array. If the array has multiple channels, a runtime
    /// error is raised. Note that Get?D functions can be used safely for both single-channel and
    /// multiple-channel arrays though they are a bit slower.
    ///
    /// In the case of a sparse array the functions return 0 if the requested node does not exist (no new
    /// node is created by the functions).
    /// @param arr Input array. Must have a single channel.
    /// @param idx0 The first zero-based component of the element index
    pub fn cvGetReal1D(arr: *const CvArr, idx0: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    /// @overload
    pub fn cvGetReal2D(arr: *const CvArr, idx0: ::std::os::raw::c_int, idx1: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    /// @overload
    pub fn cvGetReal3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    /// @overload
    /// @param arr Input array. Must have a single channel.
    /// @param idx Array of the element indices
    pub fn cvGetRealND(arr: *const CvArr, idx: *const ::std::os::raw::c_int) -> f64;
}
extern "C" {
    /// @brief Change the particular array element.
    ///
    /// The functions assign the new value to a particular array element. In the case of a sparse array the
    /// functions create the node if it does not exist yet.
    /// @param arr Input array
    /// @param idx0 The first zero-based component of the element index
    /// @param value The assigned value
    pub fn cvSet1D(arr: *mut CvArr, idx0: ::std::os::raw::c_int, value: CvScalar);
}
extern "C" {
    /// @overload
    pub fn cvSet2D(arr: *mut CvArr, idx0: ::std::os::raw::c_int, idx1: ::std::os::raw::c_int, value: CvScalar);
}
extern "C" {
    /// @overload
    pub fn cvSet3D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    /// @overload
    /// @param arr Input array
    /// @param idx Array of the element indices
    /// @param value The assigned value
    pub fn cvSetND(arr: *mut CvArr, idx: *const ::std::os::raw::c_int, value: CvScalar);
}
extern "C" {
    /// @brief Change a specific array element.
    ///
    /// The functions assign a new value to a specific element of a single-channel array. If the array has
    /// multiple channels, a runtime error is raised. Note that the Set\*D function can be used safely for
    /// both single-channel and multiple-channel arrays, though they are a bit slower.
    ///
    /// In the case of a sparse array the functions create the node if it does not yet exist.
    /// @param arr Input array
    /// @param idx0 The first zero-based component of the element index
    /// @param value The assigned value
    pub fn cvSetReal1D(arr: *mut CvArr, idx0: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    /// @overload
    pub fn cvSetReal2D(arr: *mut CvArr, idx0: ::std::os::raw::c_int, idx1: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    /// @overload
    pub fn cvSetReal3D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    /// @overload
    /// @param arr Input array
    /// @param idx Array of the element indices
    /// @param value The assigned value
    pub fn cvSetRealND(arr: *mut CvArr, idx: *const ::std::os::raw::c_int, value: f64);
}
extern "C" {
    /// clears element of ND dense array,
    /// in case of sparse arrays it deletes the specified node
    pub fn cvClearND(arr: *mut CvArr, idx: *const ::std::os::raw::c_int);
}
extern "C" {
    /// @brief Returns matrix header for arbitrary array.
    ///
    /// The function returns a matrix header for the input array that can be a matrix - CvMat, an image -
    /// IplImage, or a multi-dimensional dense array - CvMatND (the third option is allowed only if
    /// allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of
    /// IplImage\* or CvMatND it initializes the header structure with parameters of the current image ROI
    /// and returns &header. Because COI is not supported by CvMat, it is returned separately.
    ///
    /// The function provides an easy way to handle both types of arrays - IplImage and CvMat using the same
    /// code. Input array must have non-zero data pointer, otherwise the function will report an error.
    ///
    /// @note If the input array is IplImage with planar data layout and COI set, the function returns the
    /// pointer to the selected plane and COI == 0. This feature allows user to process IplImage structures
    /// with planar data layout, even though OpenCV does not support such images.
    /// @param arr Input array
    /// @param header Pointer to CvMat structure used as a temporary buffer
    /// @param coi Optional output parameter for storing COI
    /// @param allowND If non-zero, the function accepts multi-dimensional dense arrays (CvMatND\*) and
    /// returns 2D matrix (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or
    /// more than 2 dimensions). The CvMatND array must be continuous.
    /// @sa cvGetImage, cvarrToMat.
    pub fn cvGetMat(
        arr: *const CvArr,
        header: *mut CvMat,
        coi: *mut ::std::os::raw::c_int,
        allowND: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// @brief Returns image header for arbitrary array.
    ///
    /// The function returns the image header for the input array that can be a matrix (CvMat) or image
    /// (IplImage). In the case of an image the function simply returns the input pointer. In the case of
    /// CvMat it initializes an image_header structure with the parameters of the input matrix. Note that
    /// if we transform IplImage to CvMat using cvGetMat and then transform CvMat back to IplImage using
    /// this function, we will get different headers if the ROI is set in the original image.
    /// @param arr Input array
    /// @param image_header Pointer to IplImage structure used as a temporary buffer
    pub fn cvGetImage(arr: *const CvArr, image_header: *mut IplImage) -> *mut IplImage;
}
extern "C" {
    /// @brief Changes the shape of a multi-dimensional array without copying the data.
    ///
    /// The function is an advanced version of cvReshape that can work with multi-dimensional arrays as
    /// well (though it can work with ordinary images and matrices) and change the number of dimensions.
    ///
    /// Below are the two samples from the cvReshape description rewritten using cvReshapeMatND:
    /// @code
    /// IplImage* color_img = cvCreateImage(cvSize(320,240), IPL_DEPTH_8U, 3);
    /// IplImage gray_img_hdr, *gray_img;
    /// gray_img = (IplImage*)cvReshapeMatND(color_img, sizeof(gray_img_hdr), &gray_img_hdr, 1, 0, 0);
    /// ...
    /// int size[] = { 2, 2, 2 };
    /// CvMatND* mat = cvCreateMatND(3, size, CV_32F);
    /// CvMat row_header, *row;
    /// row = (CvMat*)cvReshapeMatND(mat, sizeof(row_header), &row_header, 0, 1, 0);
    /// @endcode
    /// In C, the header file for this function includes a convenient macro cvReshapeND that does away with
    /// the sizeof_header parameter. So, the lines containing the call to cvReshapeMatND in the examples
    /// may be replaced as follow:
    /// @code
    /// gray_img = (IplImage*)cvReshapeND(color_img, &gray_img_hdr, 1, 0, 0);
    /// ...
    /// row = (CvMat*)cvReshapeND(mat, &row_header, 0, 1, 0);
    /// @endcode
    /// @param arr Input array
    /// @param sizeof_header Size of output header to distinguish between IplImage, CvMat and CvMatND
    /// output headers
    /// @param header Output header to be filled
    /// @param new_cn New number of channels. new_cn = 0 means that the number of channels remains
    /// unchanged.
    /// @param new_dims New number of dimensions. new_dims = 0 means that the number of dimensions
    /// remains the same.
    /// @param new_sizes Array of new dimension sizes. Only new_dims-1 values are used, because the
    /// total number of elements must remain the same. Thus, if new_dims = 1, new_sizes array is not
    /// used.
    pub fn cvReshapeMatND(
        arr: *const CvArr,
        sizeof_header: ::std::os::raw::c_int,
        header: *mut CvArr,
        new_cn: ::std::os::raw::c_int,
        new_dims: ::std::os::raw::c_int,
        new_sizes: *mut ::std::os::raw::c_int,
    ) -> *mut CvArr;
}
extern "C" {
    /// @brief Changes shape of matrix/image without copying data.
    ///
    /// The function initializes the CvMat header so that it points to the same data as the original array
    /// but has a different shape - different number of channels, different number of rows, or both.
    ///
    /// The following example code creates one image buffer and two image headers, the first is for a
    /// 320x240x3 image and the second is for a 960x240x1 image:
    /// @code
    /// IplImage* color_img = cvCreateImage(cvSize(320,240), IPL_DEPTH_8U, 3);
    /// CvMat gray_mat_hdr;
    /// IplImage gray_img_hdr, *gray_img;
    /// cvReshape(color_img, &gray_mat_hdr, 1);
    /// gray_img = cvGetImage(&gray_mat_hdr, &gray_img_hdr);
    /// @endcode
    /// And the next example converts a 3x3 matrix to a single 1x9 vector:
    /// @code
    /// CvMat* mat = cvCreateMat(3, 3, CV_32F);
    /// CvMat row_header, *row;
    /// row = cvReshape(mat, &row_header, 0, 1);
    /// @endcode
    /// @param arr Input array
    /// @param header Output header to be filled
    /// @param new_cn New number of channels. 'new_cn = 0' means that the number of channels remains
    /// unchanged.
    /// @param new_rows New number of rows. 'new_rows = 0' means that the number of rows remains
    /// unchanged unless it needs to be changed according to new_cn value.
    pub fn cvReshape(
        arr: *const CvArr,
        header: *mut CvMat,
        new_cn: ::std::os::raw::c_int,
        new_rows: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    /// Repeats source 2d array several times in both horizontal and
    /// vertical direction to fill destination array
    pub fn cvRepeat(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// @brief Allocates array data
    ///
    /// The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of
    /// matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless
    /// CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used
    /// to allocate the data.
    /// @param arr Array header
    pub fn cvCreateData(arr: *mut CvArr);
}
extern "C" {
    /// @brief Releases array data.
    ///
    /// The function releases the array data. In the case of CvMat or CvMatND it simply calls
    /// cvDecRefData(), that is the function can not deallocate external data. See also the note to
    /// cvCreateData .
    /// @param arr Array header
    pub fn cvReleaseData(arr: *mut CvArr);
}
extern "C" {
    /// @brief Assigns user data to the array header.
    ///
    /// The function assigns user data to the array header. Header should be initialized before using
    /// cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader,
    /// cvInitImageHeader or cvInitMatNDHeader.
    /// @param arr Array header
    /// @param data User data
    /// @param step Full row length in bytes
    pub fn cvSetData(arr: *mut CvArr, data: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_int);
}
extern "C" {
    /// @brief Retrieves low-level information about the array.
    ///
    /// The function fills output variables with low-level information about the array data. All output
    ///
    /// parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with
    /// ROI set, the parameters of ROI are returned.
    ///
    /// The following example shows how to get access to array elements. It computes absolute values of the
    /// array elements :
    /// @code
    /// float* data;
    /// int step;
    /// CvSize size;
    ///
    /// cvGetRawData(array, (uchar**)&data, &step, &size);
    /// step /= sizeof(data[0]);
    ///
    /// for(int y = 0; y < size.height; y++, data += step )
    /// for(int x = 0; x < size.width; x++ )
    /// data[x] = (float)fabs(data[x]);
    /// @endcode
    /// @param arr Array header
    /// @param data Output pointer to the whole image origin or ROI origin if ROI is set
    /// @param step Output full row length in bytes
    /// @param roi_size Output ROI size
    pub fn cvGetRawData(
        arr: *const CvArr,
        data: *mut *mut uchar,
        step: *mut ::std::os::raw::c_int,
        roi_size: *mut CvSize,
    );
}
extern "C" {
    /// @brief Returns size of matrix or image ROI.
    ///
    /// The function returns number of rows (CvSize::height) and number of columns (CvSize::width) of the
    /// input matrix or image. In the case of image the size of ROI is returned.
    /// @param arr array header
    pub fn cvGetSize(arr: *const CvArr) -> CvSize;
}
extern "C" {
    /// @brief Copies one array to another.
    ///
    /// The function copies selected elements from an input array to an output array:
    ///
    /// \f[\texttt{dst} (I)= \texttt{src} (I)  \quad \text{if} \quad \texttt{mask} (I)  \ne 0.\f]
    ///
    /// If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays
    /// must have the same type, the same number of dimensions, and the same size. The function can also
    /// copy sparse arrays (mask is not supported in this case).
    /// @param src The source array
    /// @param dst The destination array
    /// @param mask Operation mask, 8-bit single channel array; specifies elements of the destination array
    /// to be changed
    pub fn cvCopy(src: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// @brief Sets every element of an array to a given value.
    ///
    /// The function copies the scalar value to every selected element of the destination array:
    /// \f[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I)  \ne 0\f]
    /// If array arr is of IplImage type, then is ROI used, but COI must not be set.
    /// @param arr The destination array
    /// @param value Fill value
    /// @param mask Operation mask, 8-bit single channel array; specifies elements of the destination
    /// array to be changed
    pub fn cvSet(arr: *mut CvArr, value: CvScalar, mask: *const CvArr);
}
extern "C" {
    /// @brief Clears the array.
    ///
    /// The function clears the array. In the case of dense arrays (CvMat, CvMatND or IplImage),
    /// cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the
    /// elements are removed.
    /// @param arr Array to be cleared
    pub fn cvSetZero(arr: *mut CvArr);
}
extern "C" {
    /// Splits a multi-channel array into the set of single-channel arrays or
    /// extracts particular [color] plane
    pub fn cvSplit(src: *const CvArr, dst0: *mut CvArr, dst1: *mut CvArr, dst2: *mut CvArr, dst3: *mut CvArr);
}
extern "C" {
    /// Merges a set of single-channel arrays into the single multi-channel array
    /// or inserts one particular [color] plane to the array
    pub fn cvMerge(src0: *const CvArr, src1: *const CvArr, src2: *const CvArr, src3: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// Copies several channels from input arrays to
    /// certain channels of output arrays
    pub fn cvMixChannels(
        src: *mut *const CvArr,
        src_count: ::std::os::raw::c_int,
        dst: *mut *mut CvArr,
        dst_count: ::std::os::raw::c_int,
        from_to: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Converts one array to another with optional linear transformation.
    ///
    /// The function has several different purposes, and thus has several different names. It copies one
    /// array to another with optional scaling, which is performed first, and/or optional type conversion,
    /// performed after:
    ///
    /// \f[\texttt{dst} (I) =  \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\f]
    ///
    /// All the channels of multi-channel arrays are processed independently.
    ///
    /// The type of conversion is done with rounding and saturation, that is if the result of scaling +
    /// conversion can not be represented exactly by a value of the destination array element type, it is
    /// set to the nearest representable value on the real axis.
    /// @param src Source array
    /// @param dst Destination array
    /// @param scale Scale factor
    /// @param shift Value added to the scaled source array elements
    pub fn cvConvertScale(src: *const CvArr, dst: *mut CvArr, scale: f64, shift: f64);
}
extern "C" {
    /// Performs linear transformation on every source array element,
    /// stores absolute value of the result:
    /// dst(x,y,c) = abs(scale*src(x,y,c)+shift).
    /// destination array must have 8u type.
    /// In other cases one may use cvConvertScale + cvAbsDiffS
    pub fn cvConvertScaleAbs(src: *const CvArr, dst: *mut CvArr, scale: f64, shift: f64);
}
extern "C" {
    /// checks termination criteria validity and
    /// sets eps to default_eps (if it is not set),
    /// max_iter to default_max_iters (if it is not set)
    pub fn cvCheckTermCriteria(
        criteria: CvTermCriteria,
        default_eps: f64,
        default_max_iters: ::std::os::raw::c_int,
    ) -> CvTermCriteria;
}
extern "C" {
    /// dst(mask) = src1(mask) + src2(mask)
    pub fn cvAdd(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(mask) = src(mask) + value
    pub fn cvAddS(src: *const CvArr, value: CvScalar, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(mask) = src1(mask) - src2(mask)
    pub fn cvSub(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(mask) = value - src(mask)
    pub fn cvSubRS(src: *const CvArr, value: CvScalar, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src1(idx) * src2(idx) * scale
    /// (scaled element-wise multiplication of 2 arrays)
    pub fn cvMul(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, scale: f64);
}
extern "C" {
    /// element-wise division/inversion with scaling:
    /// dst(idx) = src1(idx) * scale / src2(idx)
    /// or dst(idx) = scale / src2(idx) if src1 == 0
    pub fn cvDiv(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, scale: f64);
}
extern "C" {
    /// dst = src1 * scale + src2
    pub fn cvScaleAdd(src1: *const CvArr, scale: CvScalar, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst = src1 * alpha + src2 * beta + gamma
    pub fn cvAddWeighted(src1: *const CvArr, alpha: f64, src2: *const CvArr, beta: f64, gamma: f64, dst: *mut CvArr);
}
extern "C" {
    /// @brief Calculates the dot product of two arrays in Euclidean metrics.
    ///
    /// The function calculates and returns the Euclidean dot product of two arrays.
    ///
    /// \f[src1  \bullet src2 =  \sum _I ( \texttt{src1} (I)  \texttt{src2} (I))\f]
    ///
    /// In the case of multiple channel arrays, the results for all channels are accumulated. In particular,
    /// cvDotProduct(a,a) where a is a complex vector, will return \f$||\texttt{a}||^2\f$. The function can
    /// process multi-dimensional arrays, row by row, layer by layer, and so on.
    /// @param src1 The first source array
    /// @param src2 The second source array
    pub fn cvDotProduct(src1: *const CvArr, src2: *const CvArr) -> f64;
}
extern "C" {
    /// dst(idx) = src1(idx) & src2(idx)
    pub fn cvAnd(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src(idx) & value
    pub fn cvAndS(src: *const CvArr, value: CvScalar, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src1(idx) | src2(idx)
    pub fn cvOr(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src(idx) | value
    pub fn cvOrS(src: *const CvArr, value: CvScalar, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src1(idx) ^ src2(idx)
    pub fn cvXor(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = src(idx) ^ value
    pub fn cvXorS(src: *const CvArr, value: CvScalar, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    /// dst(idx) = ~src(idx)
    pub fn cvNot(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = lower(idx) <= src(idx) < upper(idx)
    pub fn cvInRange(src: *const CvArr, lower: *const CvArr, upper: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = lower <= src(idx) < upper
    pub fn cvInRangeS(src: *const CvArr, lower: CvScalar, upper: CvScalar, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = src1(idx) _cmp_op_ src2(idx)
    pub fn cvCmp(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, cmp_op: ::std::os::raw::c_int);
}
extern "C" {
    /// dst(idx) = src1(idx) _cmp_op_ value
    pub fn cvCmpS(src: *const CvArr, value: f64, dst: *mut CvArr, cmp_op: ::std::os::raw::c_int);
}
extern "C" {
    /// dst(idx) = min(src1(idx),src2(idx))
    pub fn cvMin(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = max(src1(idx),src2(idx))
    pub fn cvMax(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = min(src(idx),value)
    pub fn cvMinS(src: *const CvArr, value: f64, dst: *mut CvArr);
}
extern "C" {
    /// dst(idx) = max(src(idx),value)
    pub fn cvMaxS(src: *const CvArr, value: f64, dst: *mut CvArr);
}
extern "C" {
    /// dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))
    pub fn cvAbsDiff(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// dst(x,y,c) = abs(src(x,y,c) - value(c))
    pub fn cvAbsDiffS(src: *const CvArr, dst: *mut CvArr, value: CvScalar);
}
extern "C" {
    /// Does cartesian->polar coordinates conversion.
    /// Either of output components (magnitude or angle) is optional
    pub fn cvCartToPolar(
        x: *const CvArr,
        y: *const CvArr,
        magnitude: *mut CvArr,
        angle: *mut CvArr,
        angle_in_degrees: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Does polar->cartesian coordinates conversion.
    /// Either of output components (magnitude or angle) is optional.
    /// If magnitude is missing it is assumed to be all 1's
    pub fn cvPolarToCart(
        magnitude: *const CvArr,
        angle: *const CvArr,
        x: *mut CvArr,
        y: *mut CvArr,
        angle_in_degrees: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Does powering: dst(idx) = src(idx)^power
    pub fn cvPow(src: *const CvArr, dst: *mut CvArr, power: f64);
}
extern "C" {
    /// Does exponention: dst(idx) = exp(src(idx)).
    /// Overflow is not handled yet. Underflow is handled.
    /// Maximal relative error is ~7e-6 for single-precision input
    pub fn cvExp(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// Calculates natural logarithms: dst(idx) = log(abs(src(idx))).
    /// Logarithm of 0 gives large negative number(~-700)
    /// Maximal relative error is ~3e-7 for single-precision output
    pub fn cvLog(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// Fast arctangent calculation
    pub fn cvFastArctan(y: f32, x: f32) -> f32;
}
extern "C" {
    /// Fast cubic root calculation
    pub fn cvCbrt(value: f32) -> f32;
}
extern "C" {
    /// Checks array values for NaNs, Infs or simply for too large numbers
    /// (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
    /// no runtime errors is raised (function returns zero value in case of "bad" values).
    /// Otherwise cvError is called
    pub fn cvCheckArr(
        arr: *const CvArr,
        flags: ::std::os::raw::c_int,
        min_val: f64,
        max_val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Fills an array with random numbers and updates the RNG state.
    ///
    /// The function fills the destination array with uniformly or normally distributed random numbers.
    /// @param rng CvRNG state initialized by cvRNG
    /// @param arr The destination array
    /// @param dist_type Distribution type
    /// > -   **CV_RAND_UNI** uniform distribution
    /// > -   **CV_RAND_NORMAL** normal or Gaussian distribution
    /// @param param1 The first parameter of the distribution. In the case of a uniform distribution it is
    /// the inclusive lower boundary of the random numbers range. In the case of a normal distribution it
    /// is the mean value of the random numbers.
    /// @param param2 The second parameter of the distribution. In the case of a uniform distribution it
    /// is the exclusive upper boundary of the random numbers range. In the case of a normal distribution
    /// it is the standard deviation of the random numbers.
    /// @sa randu, randn, RNG::fill.
    pub fn cvRandArr(
        rng: *mut CvRNG,
        arr: *mut CvArr,
        dist_type: ::std::os::raw::c_int,
        param1: CvScalar,
        param2: CvScalar,
    );
}
extern "C" {
    pub fn cvRandShuffle(mat: *mut CvArr, rng: *mut CvRNG, iter_factor: f64);
}
extern "C" {
    pub fn cvSort(src: *const CvArr, dst: *mut CvArr, idxmat: *mut CvArr, flags: ::std::os::raw::c_int);
}
extern "C" {
    /// Finds real roots of a cubic equation
    pub fn cvSolveCubic(coeffs: *const CvMat, roots: *mut CvMat) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Finds all real and complex roots of a polynomial equation
    pub fn cvSolvePoly(
        coeffs: *const CvMat,
        roots2: *mut CvMat,
        maxiter: ::std::os::raw::c_int,
        fig: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Calculates the cross product of two 3D vectors.
    ///
    /// The function calculates the cross product of two 3D vectors:
    /// \f[\texttt{dst} =  \texttt{src1} \times \texttt{src2}\f]
    /// or:
    /// \f[\begin{array}{l} \texttt{dst} _1 =  \texttt{src1} _2  \texttt{src2} _3 -  \texttt{src1} _3  \texttt{src2} _2 \\ \texttt{dst} _2 =  \texttt{src1} _3  \texttt{src2} _1 -  \texttt{src1} _1  \texttt{src2} _3 \\ \texttt{dst} _3 =  \texttt{src1} _1  \texttt{src2} _2 -  \texttt{src1} _2  \texttt{src2} _1 \end{array}\f]
    /// @param src1 The first source vector
    /// @param src2 The second source vector
    /// @param dst The destination vector
    pub fn cvCrossProduct(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// Extended matrix transform:
    /// dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T
    pub fn cvGEMM(
        src1: *const CvArr,
        src2: *const CvArr,
        alpha: f64,
        src3: *const CvArr,
        beta: f64,
        dst: *mut CvArr,
        tABC: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Transforms each element of source array and stores
    /// resultant vectors in destination array
    pub fn cvTransform(src: *const CvArr, dst: *mut CvArr, transmat: *const CvMat, shiftvec: *const CvMat);
}
extern "C" {
    /// Does perspective transform on every element of input array
    pub fn cvPerspectiveTransform(src: *const CvArr, dst: *mut CvArr, mat: *const CvMat);
}
extern "C" {
    /// Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)
    pub fn cvMulTransposed(
        src: *const CvArr,
        dst: *mut CvArr,
        order: ::std::os::raw::c_int,
        delta: *const CvArr,
        scale: f64,
    );
}
extern "C" {
    /// Tranposes matrix. Square matrices can be transposed in-place
    pub fn cvTranspose(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    /// Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part
    pub fn cvCompleteSymm(matrix: *mut CvMat, LtoR: ::std::os::raw::c_int);
}
extern "C" {
    /// Mirror array data around horizontal (flip=0),
    /// vertical (flip=1) or both(flip=-1) axises:
    /// cvFlip(src) flips images vertically and sequences horizontally (inplace)
    pub fn cvFlip(src: *const CvArr, dst: *mut CvArr, flip_mode: ::std::os::raw::c_int);
}
extern "C" {
    /// Performs Singular Value Decomposition of a matrix
    pub fn cvSVD(A: *mut CvArr, W: *mut CvArr, U: *mut CvArr, V: *mut CvArr, flags: ::std::os::raw::c_int);
}
extern "C" {
    /// Performs Singular Value Back Substitution (solves A*X = B):
    /// flags must be the same as in cvSVD
    pub fn cvSVBkSb(
        W: *const CvArr,
        U: *const CvArr,
        V: *const CvArr,
        B: *const CvArr,
        X: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Inverts matrix
    pub fn cvInvert(src: *const CvArr, dst: *mut CvArr, method: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    /// Solves linear system (src1)*(dst) = (src2)
    /// (returns 0 if src1 is a singular and CV_LU method is used)
    pub fn cvSolve(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        method: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates determinant of input matrix
    pub fn cvDet(mat: *const CvArr) -> f64;
}
extern "C" {
    /// Calculates trace of the matrix (sum of elements on the main diagonal)
    pub fn cvTrace(mat: *const CvArr) -> CvScalar;
}
extern "C" {
    /// Finds eigen values and vectors of a symmetric matrix
    pub fn cvEigenVV(
        mat: *mut CvArr,
        evects: *mut CvArr,
        evals: *mut CvArr,
        eps: f64,
        lowindex: ::std::os::raw::c_int,
        highindex: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Makes an identity matrix (mat_ij = i == j)
    pub fn cvSetIdentity(mat: *mut CvArr, value: CvScalar);
}
extern "C" {
    /// Fills matrix with given range of numbers
    pub fn cvRange(mat: *mut CvArr, start: f64, end: f64) -> *mut CvArr;
}
extern "C" {
    /// Calculates covariation matrix for a set of vectors
    /// @see @ref core_c_CovarFlags "flags"
    pub fn cvCalcCovarMatrix(
        vects: *mut *const CvArr,
        count: ::std::os::raw::c_int,
        cov_mat: *mut CvArr,
        avg: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCalcPCA(
        data: *const CvArr,
        mean: *mut CvArr,
        eigenvals: *mut CvArr,
        eigenvects: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvProjectPCA(data: *const CvArr, mean: *const CvArr, eigenvects: *const CvArr, result: *mut CvArr);
}
extern "C" {
    pub fn cvBackProjectPCA(proj: *const CvArr, mean: *const CvArr, eigenvects: *const CvArr, result: *mut CvArr);
}
extern "C" {
    /// Calculates Mahalanobis(weighted) distance
    pub fn cvMahalanobis(vec1: *const CvArr, vec2: *const CvArr, mat: *const CvArr) -> f64;
}
extern "C" {
    /// Finds sum of array elements
    pub fn cvSum(arr: *const CvArr) -> CvScalar;
}
extern "C" {
    /// Calculates number of non-zero pixels
    pub fn cvCountNonZero(arr: *const CvArr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates mean value of array elements
    pub fn cvAvg(arr: *const CvArr, mask: *const CvArr) -> CvScalar;
}
extern "C" {
    /// Calculates mean and standard deviation of pixel values
    pub fn cvAvgSdv(arr: *const CvArr, mean: *mut CvScalar, std_dev: *mut CvScalar, mask: *const CvArr);
}
extern "C" {
    /// Finds global minimum, maximum and their positions
    pub fn cvMinMaxLoc(
        arr: *const CvArr,
        min_val: *mut f64,
        max_val: *mut f64,
        min_loc: *mut CvPoint,
        max_loc: *mut CvPoint,
        mask: *const CvArr,
    );
}
extern "C" {
    /// Finds norm, difference norm or relative difference norm for an array (or two arrays)
    /// @see ref core_c_NormFlags "flags"
    pub fn cvNorm(arr1: *const CvArr, arr2: *const CvArr, norm_type: ::std::os::raw::c_int, mask: *const CvArr) -> f64;
}
extern "C" {
    /// @see ref core_c_NormFlags "flags"
    pub fn cvNormalize(
        src: *const CvArr,
        dst: *mut CvArr,
        a: f64,
        b: f64,
        norm_type: ::std::os::raw::c_int,
        mask: *const CvArr,
    );
}
extern "C" {
    /// @see @ref core_c_ReduceFlags "flags"
    pub fn cvReduce(src: *const CvArr, dst: *mut CvArr, dim: ::std::os::raw::c_int, op: ::std::os::raw::c_int);
}
extern "C" {
    /// Discrete Fourier Transform:
    /// complex->complex,
    /// real->ccs (forward),
    /// ccs->real (inverse)
    /// @see core_c_DftFlags "flags"
    pub fn cvDFT(src: *const CvArr, dst: *mut CvArr, flags: ::std::os::raw::c_int, nonzero_rows: ::std::os::raw::c_int);
}
extern "C" {
    /// Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y))
    /// @see core_c_DftFlags "flags"
    pub fn cvMulSpectrums(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr, flags: ::std::os::raw::c_int);
}
extern "C" {
    /// Finds optimal DFT vector size >= size0
    pub fn cvGetOptimalDFTSize(size0: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Discrete Cosine Transform
    /// @see core_c_DftFlags "flags"
    pub fn cvDCT(src: *const CvArr, dst: *mut CvArr, flags: ::std::os::raw::c_int);
}
extern "C" {
    /// Calculates length of sequence slice (with support of negative indices).
    pub fn cvSliceLength(slice: CvSlice, seq: *const CvSeq) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates new memory storage.
    /// block_size == 0 means that default,
    /// somewhat optimal size, is used (currently, it is 64K)
    pub fn cvCreateMemStorage(block_size: ::std::os::raw::c_int) -> *mut CvMemStorage;
}
extern "C" {
    /// Creates a memory storage that will borrow memory blocks from parent storage
    pub fn cvCreateChildMemStorage(parent: *mut CvMemStorage) -> *mut CvMemStorage;
}
extern "C" {
    /// Releases memory storage. All the children of a parent must be released before
    /// the parent. A child storage returns all the blocks to parent when it is released
    pub fn cvReleaseMemStorage(storage: *mut *mut CvMemStorage);
}
extern "C" {
    /// Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)
    /// to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...
    /// do not free any memory.
    /// A child storage returns all the blocks to the parent when it is cleared
    pub fn cvClearMemStorage(storage: *mut CvMemStorage);
}
extern "C" {
    /// Remember a storage "free memory" position
    pub fn cvSaveMemStoragePos(storage: *const CvMemStorage, pos: *mut CvMemStoragePos);
}
extern "C" {
    /// Restore a storage "free memory" position
    pub fn cvRestoreMemStoragePos(storage: *mut CvMemStorage, pos: *mut CvMemStoragePos);
}
extern "C" {
    /// Allocates continuous buffer of the specified size in the storage
    pub fn cvMemStorageAlloc(storage: *mut CvMemStorage, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocates string in memory storage
    pub fn cvMemStorageAllocString(
        storage: *mut CvMemStorage,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> CvString;
}
extern "C" {
    /// Creates new empty sequence that will reside in the specified storage
    pub fn cvCreateSeq(
        seq_flags: ::std::os::raw::c_int,
        header_size: usize,
        elem_size: usize,
        storage: *mut CvMemStorage,
    ) -> *mut CvSeq;
}
extern "C" {
    /// Changes default size (granularity) of sequence blocks.
    /// The default size is ~1Kbyte
    pub fn cvSetSeqBlockSize(seq: *mut CvSeq, delta_elems: ::std::os::raw::c_int);
}
extern "C" {
    /// Adds new element to the end of sequence. Returns pointer to the element
    pub fn cvSeqPush(seq: *mut CvSeq, element: *const ::std::os::raw::c_void) -> *mut schar;
}
extern "C" {
    /// Adds new element to the beginning of sequence. Returns pointer to it
    pub fn cvSeqPushFront(seq: *mut CvSeq, element: *const ::std::os::raw::c_void) -> *mut schar;
}
extern "C" {
    /// Removes the last element from sequence and optionally saves it
    pub fn cvSeqPop(seq: *mut CvSeq, element: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Removes the first element from sequence and optioanally saves it
    pub fn cvSeqPopFront(seq: *mut CvSeq, element: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Adds several new elements to the end of sequence
    pub fn cvSeqPushMulti(
        seq: *mut CvSeq,
        elements: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_int,
        in_front: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Removes several elements from the end of sequence and optionally saves them
    pub fn cvSeqPopMulti(
        seq: *mut CvSeq,
        elements: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_int,
        in_front: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Inserts a new element in the middle of sequence.
    /// cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem)
    pub fn cvSeqInsert(
        seq: *mut CvSeq,
        before_index: ::std::os::raw::c_int,
        element: *const ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    /// Removes specified sequence element
    pub fn cvSeqRemove(seq: *mut CvSeq, index: ::std::os::raw::c_int);
}
extern "C" {
    /// Removes all the elements from the sequence. The freed memory
    /// can be reused later only by the same sequence unless cvClearMemStorage
    /// or cvRestoreMemStoragePos is called
    pub fn cvClearSeq(seq: *mut CvSeq);
}
extern "C" {
    /// Retrieves pointer to specified sequence element.
    /// Negative indices are supported and mean counting from the end
    /// (e.g -1 means the last sequence element)
    pub fn cvGetSeqElem(seq: *const CvSeq, index: ::std::os::raw::c_int) -> *mut schar;
}
extern "C" {
    /// Calculates index of the specified sequence element.
    /// Returns -1 if element does not belong to the sequence
    pub fn cvSeqElemIdx(
        seq: *const CvSeq,
        element: *const ::std::os::raw::c_void,
        block: *mut *mut CvSeqBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initializes sequence writer. The new elements will be added to the end of sequence
    pub fn cvStartAppendToSeq(seq: *mut CvSeq, writer: *mut CvSeqWriter);
}
extern "C" {
    /// Combination of cvCreateSeq and cvStartAppendToSeq
    pub fn cvStartWriteSeq(
        seq_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
        writer: *mut CvSeqWriter,
    );
}
extern "C" {
    /// Closes sequence writer, updates sequence header and returns pointer
    /// to the resultant sequence
    /// (which may be useful if the sequence was created using cvStartWriteSeq))
    pub fn cvEndWriteSeq(writer: *mut CvSeqWriter) -> *mut CvSeq;
}
extern "C" {
    /// Updates sequence header. May be useful to get access to some of previously
    /// written elements via cvGetSeqElem or sequence reader
    pub fn cvFlushSeqWriter(writer: *mut CvSeqWriter);
}
extern "C" {
    /// Initializes sequence reader.
    /// The sequence can be read in forward or backward direction
    pub fn cvStartReadSeq(seq: *const CvSeq, reader: *mut CvSeqReader, reverse: ::std::os::raw::c_int);
}
extern "C" {
    /// Returns current sequence reader position (currently observed sequence element)
    pub fn cvGetSeqReaderPos(reader: *mut CvSeqReader) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Changes sequence reader position. It may seek to an absolute or
    /// to relative to the current position
    pub fn cvSetSeqReaderPos(
        reader: *mut CvSeqReader,
        index: ::std::os::raw::c_int,
        is_relative: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Copies sequence content to a continuous piece of memory
    pub fn cvCvtSeqToArray(
        seq: *const CvSeq,
        elements: *mut ::std::os::raw::c_void,
        slice: CvSlice,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Creates sequence header for array.
    /// After that all the operations on sequences that do not alter the content
    /// can be applied to the resultant sequence
    pub fn cvMakeSeqHeaderForArray(
        seq_type: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_void,
        total: ::std::os::raw::c_int,
        seq: *mut CvSeq,
        block: *mut CvSeqBlock,
    ) -> *mut CvSeq;
}
extern "C" {
    /// Extracts sequence slice (with or without copying sequence elements)
    pub fn cvSeqSlice(
        seq: *const CvSeq,
        slice: CvSlice,
        storage: *mut CvMemStorage,
        copy_data: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    /// Removes sequence slice
    pub fn cvSeqRemoveSlice(seq: *mut CvSeq, slice: CvSlice);
}
extern "C" {
    /// Inserts a sequence or array into another sequence
    pub fn cvSeqInsertSlice(seq: *mut CvSeq, before_index: ::std::os::raw::c_int, from_arr: *const CvArr);
}
/// a < b ? -1 : a > b ? 1 : 0
pub type CvCmpFunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Sorts sequence in-place given element comparison function
    pub fn cvSeqSort(seq: *mut CvSeq, func: CvCmpFunc, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Finds element in a [sorted] sequence
    pub fn cvSeqSearch(
        seq: *mut CvSeq,
        elem: *const ::std::os::raw::c_void,
        func: CvCmpFunc,
        is_sorted: ::std::os::raw::c_int,
        elem_idx: *mut ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    /// Reverses order of sequence elements in-place
    pub fn cvSeqInvert(seq: *mut CvSeq);
}
extern "C" {
    /// Splits sequence into one or more equivalence classes using the specified criteria
    pub fn cvSeqPartition(
        seq: *const CvSeq,
        storage: *mut CvMemStorage,
        labels: *mut *mut CvSeq,
        is_equal: CvCmpFunc,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Internal sequence functions
    pub fn cvChangeSeqBlock(reader: *mut ::std::os::raw::c_void, direction: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvCreateSeqBlock(writer: *mut CvSeqWriter);
}
extern "C" {
    /// Creates a new set
    pub fn cvCreateSet(
        set_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvSet;
}
extern "C" {
    /// Adds new element to the set and returns pointer to it
    pub fn cvSetAdd(
        set_header: *mut CvSet,
        elem: *mut CvSetElem,
        inserted_elem: *mut *mut CvSetElem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Removes element from the set by its index
    pub fn cvSetRemove(set_header: *mut CvSet, index: ::std::os::raw::c_int);
}
extern "C" {
    /// Removes all the elements from the set
    pub fn cvClearSet(set_header: *mut CvSet);
}
extern "C" {
    /// Creates new graph
    pub fn cvCreateGraph(
        graph_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        vtx_size: ::std::os::raw::c_int,
        edge_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvGraph;
}
extern "C" {
    /// Adds new vertex to the graph
    pub fn cvGraphAddVtx(
        graph: *mut CvGraph,
        vtx: *const CvGraphVtx,
        inserted_vtx: *mut *mut CvGraphVtx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Removes vertex from the graph together with all incident edges
    pub fn cvGraphRemoveVtx(graph: *mut CvGraph, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphRemoveVtxByPtr(graph: *mut CvGraph, vtx: *mut CvGraphVtx) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Link two vertices specifed by indices or pointers if they
    /// are not connected or return pointer to already existing edge
    /// connecting the vertices.
    /// Functions return 1 if a new edge was created, 0 otherwise
    pub fn cvGraphAddEdge(
        graph: *mut CvGraph,
        start_idx: ::std::os::raw::c_int,
        end_idx: ::std::os::raw::c_int,
        edge: *const CvGraphEdge,
        inserted_edge: *mut *mut CvGraphEdge,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphAddEdgeByPtr(
        graph: *mut CvGraph,
        start_vtx: *mut CvGraphVtx,
        end_vtx: *mut CvGraphVtx,
        edge: *const CvGraphEdge,
        inserted_edge: *mut *mut CvGraphEdge,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove edge connecting two vertices
    pub fn cvGraphRemoveEdge(graph: *mut CvGraph, start_idx: ::std::os::raw::c_int, end_idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvGraphRemoveEdgeByPtr(graph: *mut CvGraph, start_vtx: *mut CvGraphVtx, end_vtx: *mut CvGraphVtx);
}
extern "C" {
    /// Find edge connecting two vertices
    pub fn cvFindGraphEdge(
        graph: *const CvGraph,
        start_idx: ::std::os::raw::c_int,
        end_idx: ::std::os::raw::c_int,
    ) -> *mut CvGraphEdge;
}
extern "C" {
    pub fn cvFindGraphEdgeByPtr(
        graph: *const CvGraph,
        start_vtx: *const CvGraphVtx,
        end_vtx: *const CvGraphVtx,
    ) -> *mut CvGraphEdge;
}
extern "C" {
    /// Remove all vertices and edges from the graph
    pub fn cvClearGraph(graph: *mut CvGraph);
}
extern "C" {
    /// Count number of edges incident to the vertex
    pub fn cvGraphVtxDegree(graph: *const CvGraph, vtx_idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphVtxDegreeByPtr(graph: *const CvGraph, vtx: *const CvGraphVtx) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphScanner {
    pub vtx: *mut CvGraphVtx,
    pub dst: *mut CvGraphVtx,
    pub edge: *mut CvGraphEdge,
    pub graph: *mut CvGraph,
    pub stack: *mut CvSeq,
    pub index: ::std::os::raw::c_int,
    pub mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvGraphScanner() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphScanner>(),
        48usize,
        concat!("Size of: ", stringify!(CvGraphScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphScanner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).vtx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(vtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).dst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).edge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(edge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).graph as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).stack as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraphScanner>())).mask as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    /// Creates new graph scanner.
    pub fn cvCreateGraphScanner(
        graph: *mut CvGraph,
        vtx: *mut CvGraphVtx,
        mask: ::std::os::raw::c_int,
    ) -> *mut CvGraphScanner;
}
extern "C" {
    /// Releases graph scanner.
    pub fn cvReleaseGraphScanner(scanner: *mut *mut CvGraphScanner);
}
extern "C" {
    /// Get next graph element
    pub fn cvNextGraphItem(scanner: *mut CvGraphScanner) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates a copy of graph
    pub fn cvCloneGraph(graph: *const CvGraph, storage: *mut CvMemStorage) -> *mut CvGraph;
}
extern "C" {
    /// Does look-up transformation. Elements of the source array
    /// (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table
    pub fn cvLUT(src: *const CvArr, dst: *mut CvArr, lut: *const CvArr);
}
/// Iteration through the sequence tree
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTreeNodeIterator {
    pub node: *const ::std::os::raw::c_void,
    pub level: ::std::os::raw::c_int,
    pub max_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvTreeNodeIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvTreeNodeIterator>(),
        16usize,
        concat!("Size of: ", stringify!(CvTreeNodeIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTreeNodeIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTreeNodeIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTreeNodeIterator>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTreeNodeIterator>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvTreeNodeIterator>())).max_level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(max_level)
        )
    );
}
extern "C" {
    pub fn cvInitTreeNodeIterator(
        tree_iterator: *mut CvTreeNodeIterator,
        first: *const ::std::os::raw::c_void,
        max_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvNextTreeNode(tree_iterator: *mut CvTreeNodeIterator) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvPrevTreeNode(tree_iterator: *mut CvTreeNodeIterator) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Inserts sequence into tree with specified "parent" sequence.
    /// If parent is equal to frame (e.g. the most external contour),
    /// then added contour will have null pointer to parent.
    pub fn cvInsertNodeIntoTree(
        node: *mut ::std::os::raw::c_void,
        parent: *mut ::std::os::raw::c_void,
        frame: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Removes contour from tree (together with the contour children).
    pub fn cvRemoveNodeFromTree(node: *mut ::std::os::raw::c_void, frame: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Gathers pointers to all the sequences,
    /// accessible from the `first`, to the single sequence
    pub fn cvTreeToNodeSeq(
        first: *const ::std::os::raw::c_void,
        header_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvSeq;
}
extern "C" {
    pub fn cvKMeans2(
        samples: *const CvArr,
        cluster_count: ::std::os::raw::c_int,
        labels: *mut CvArr,
        termcrit: CvTermCriteria,
        attempts: ::std::os::raw::c_int,
        rng: *mut CvRNG,
        flags: ::std::os::raw::c_int,
        _centers: *mut CvArr,
        compactness: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Loads optimized functions from IPP, MKL etc. or switches back to pure C code
    pub fn cvUseOptimized(on_off: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type Cv_iplCreateImageHeader = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
        arg11: *mut IplROI,
        arg12: *mut IplImage,
        arg13: *mut ::std::os::raw::c_void,
        arg14: *mut IplTileInfo,
    ) -> *mut IplImage,
>;
pub type Cv_iplAllocateImageData = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut IplImage, arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int),
>;
pub type Cv_iplDeallocate =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut IplImage, arg2: ::std::os::raw::c_int)>;
pub type Cv_iplCreateROI = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> *mut IplROI,
>;
pub type Cv_iplCloneImage = ::std::option::Option<unsafe extern "C" fn(arg1: *const IplImage) -> *mut IplImage>;
extern "C" {
    /// @brief Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.
    ///
    /// Normally, the function is not called directly. Instead, a simple macro
    /// CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers
    /// to IPL allocation functions. :
    /// @code
    /// ...
    /// CV_TURN_ON_IPL_COMPATIBILITY()
    /// ...
    /// @endcode
    /// @param create_header pointer to a function, creating IPL image header.
    /// @param allocate_data pointer to a function, allocating IPL image data.
    /// @param deallocate pointer to a function, deallocating IPL image.
    /// @param create_roi pointer to a function, creating IPL image ROI (i.e. Region of Interest).
    /// @param clone_image pointer to a function, cloning an IPL image.
    pub fn cvSetIPLAllocators(
        create_header: Cv_iplCreateImageHeader,
        allocate_data: Cv_iplAllocateImageData,
        deallocate: Cv_iplDeallocate,
        create_roi: Cv_iplCreateROI,
        clone_image: Cv_iplCloneImage,
    );
}
extern "C" {
    /// @brief Opens file storage for reading or writing data.
    ///
    /// The function opens file storage for reading or writing data. In the latter case, a new file is
    /// created or an existing file is rewritten. The type of the read or written file is determined by the
    /// filename extension: .xml for XML, .yml or .yaml for YAML and .json for JSON.
    ///
    /// At the same time, it also supports adding parameters like "example.xml?base64". The three ways
    /// are the same:
    /// @snippet samples/cpp/filestorage_base64.cpp suffix_in_file_name
    /// @snippet samples/cpp/filestorage_base64.cpp flag_write_base64
    /// @snippet samples/cpp/filestorage_base64.cpp flag_write_and_flag_base64
    ///
    /// The function returns a pointer to the CvFileStorage structure.
    /// If the file cannot be opened then the function returns NULL.
    /// @param filename Name of the file associated with the storage
    /// @param memstorage Memory storage used for temporary data and for
    /// :   storing dynamic structures, such as CvSeq or CvGraph . If it is NULL, a temporary memory
    /// storage is created and used.
    /// @param flags Can be one of the following:
    /// > -   **CV_STORAGE_READ** the storage is open for reading
    /// > -   **CV_STORAGE_WRITE** the storage is open for writing
    /// (use **CV_STORAGE_WRITE | CV_STORAGE_WRITE_BASE64** to write rawdata in Base64)
    /// @param encoding
    pub fn cvOpenFileStorage(
        filename: *const ::std::os::raw::c_char,
        memstorage: *mut CvMemStorage,
        flags: ::std::os::raw::c_int,
        encoding: *const ::std::os::raw::c_char,
    ) -> *mut CvFileStorage;
}
extern "C" {
    /// @brief Releases file storage.
    ///
    /// The function closes the file associated with the storage and releases all the temporary structures.
    /// It must be called after all I/O operations with the storage are finished.
    /// @param fs Double pointer to the released file storage
    pub fn cvReleaseFileStorage(fs: *mut *mut CvFileStorage);
}
extern "C" {
    /// returns attribute value or 0 (NULL) if there is no such attribute
    pub fn cvAttrValue(
        attr: *const CvAttrList,
        attr_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Starts writing a new structure.
    ///
    /// The function starts writing a compound structure (collection) that can be a sequence or a map. After
    /// all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should
    /// be called. The function can be used to group some objects or to implement the write function for a
    /// some user object (see CvTypeInfo).
    /// @param fs File storage
    /// @param name Name of the written structure. The structure can be accessed by this name when the
    /// storage is read.
    /// @param struct_flags A combination one of the following values:
    /// -   **CV_NODE_SEQ** the written structure is a sequence (see discussion of CvFileStorage ),
    /// that is, its elements do not have a name.
    /// -   **CV_NODE_MAP** the written structure is a map (see discussion of CvFileStorage ), that
    /// is, all its elements have names.
    /// One and only one of the two above flags must be specified
    /// -   **CV_NODE_FLOW** the optional flag that makes sense only for YAML streams. It means that
    /// the structure is written as a flow (not as a block), which is more compact. It is
    /// recommended to use this flag for structures or arrays whose elements are all scalars.
    /// @param type_name Optional parameter - the object type name. In
    /// case of XML it is written as a type_id attribute of the structure opening tag. In the case of
    /// YAML it is written after a colon following the structure name (see the example in
    /// CvFileStorage description). In case of JSON it is written as a name/value pair.
    /// Mainly it is used with user objects. When the storage is read, the
    /// encoded type name is used to determine the object type (see CvTypeInfo and cvFindType ).
    /// @param attributes This parameter is not used in the current implementation
    pub fn cvStartWriteStruct(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        struct_flags: ::std::os::raw::c_int,
        type_name: *const ::std::os::raw::c_char,
        attributes: CvAttrList,
    );
}
extern "C" {
    /// @brief Finishes writing to a file node collection.
    /// @param fs File storage
    /// @sa cvStartWriteStruct.
    pub fn cvEndWriteStruct(fs: *mut CvFileStorage);
}
extern "C" {
    /// @brief Writes an integer value.
    ///
    /// The function writes a single integer value (with or without a name) to the file storage.
    /// @param fs File storage
    /// @param name Name of the written value. Should be NULL if and only if the parent structure is a
    /// sequence.
    /// @param value The written value
    pub fn cvWriteInt(fs: *mut CvFileStorage, name: *const ::std::os::raw::c_char, value: ::std::os::raw::c_int);
}
extern "C" {
    /// @brief Writes a floating-point value.
    ///
    /// The function writes a single floating-point value (with or without a name) to file storage. Special
    /// values are encoded as follows: NaN (Not A Number) as .NaN, infinity as +.Inf or -.Inf.
    ///
    /// The following example shows how to use the low-level writing functions to store custom structures,
    /// such as termination criteria, without registering a new type. :
    /// @code
    /// void write_termcriteria( CvFileStorage* fs, const char* struct_name,
    /// CvTermCriteria* termcrit )
    /// {
    /// cvStartWriteStruct( fs, struct_name, CV_NODE_MAP, NULL, cvAttrList(0,0));
    /// cvWriteComment( fs, "termination criteria", 1 ); // just a description
    /// if( termcrit->type & CV_TERMCRIT_ITER )
    /// cvWriteInteger( fs, "max_iterations", termcrit->max_iter );
    /// if( termcrit->type & CV_TERMCRIT_EPS )
    /// cvWriteReal( fs, "accuracy", termcrit->epsilon );
    /// cvEndWriteStruct( fs );
    /// }
    /// @endcode
    /// @param fs File storage
    /// @param name Name of the written value. Should be NULL if and only if the parent structure is a
    /// sequence.
    /// @param value The written value
    pub fn cvWriteReal(fs: *mut CvFileStorage, name: *const ::std::os::raw::c_char, value: f64);
}
extern "C" {
    /// @brief Writes a text string.
    ///
    /// The function writes a text string to file storage.
    /// @param fs File storage
    /// @param name Name of the written string . Should be NULL if and only if the parent structure is a
    /// sequence.
    /// @param str The written text string
    /// @param quote If non-zero, the written string is put in quotes, regardless of whether they are
    /// required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when
    /// the string starts with a digit or contains spaces).
    pub fn cvWriteString(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        str: *const ::std::os::raw::c_char,
        quote: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Writes a comment.
    ///
    /// The function writes a comment into file storage. The comments are skipped when the storage is read.
    /// @param fs File storage
    /// @param comment The written comment, single-line or multi-line
    /// @param eol_comment If non-zero, the function tries to put the comment at the end of current line.
    /// If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current
    /// line, the comment starts a new line.
    pub fn cvWriteComment(
        fs: *mut CvFileStorage,
        comment: *const ::std::os::raw::c_char,
        eol_comment: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Writes an object to file storage.
    ///
    /// The function writes an object to file storage. First, the appropriate type info is found using
    /// cvTypeOf. Then, the write method associated with the type info is called.
    ///
    /// Attributes are used to customize the writing procedure. The standard types support the following
    /// attributes (all the dt attributes have the same format as in cvWriteRawData):
    ///
    /// -# CvSeq
    /// -   **header_dt** description of user fields of the sequence header that follow CvSeq, or
    /// CvChain (if the sequence is a Freeman chain) or CvContour (if the sequence is a contour or
    /// point sequence)
    /// -   **dt** description of the sequence elements.
    /// -   **recursive** if the attribute is present and is not equal to "0" or "false", the whole
    /// tree of sequences (contours) is stored.
    /// -# CvGraph
    /// -   **header_dt** description of user fields of the graph header that follows CvGraph;
    /// -   **vertex_dt** description of user fields of graph vertices
    /// -   **edge_dt** description of user fields of graph edges (note that the edge weight is
    /// always written, so there is no need to specify it explicitly)
    ///
    /// Below is the code that creates the YAML file shown in the CvFileStorage description:
    /// @code
    /// #include "cxcore.h"
    ///
    /// int main( int argc, char** argv )
    /// {
    /// CvMat* mat = cvCreateMat( 3, 3, CV_32F );
    /// CvFileStorage* fs = cvOpenFileStorage( "example.yml", 0, CV_STORAGE_WRITE );
    ///
    /// cvSetIdentity( mat );
    /// cvWrite( fs, "A", mat, cvAttrList(0,0) );
    ///
    /// cvReleaseFileStorage( &fs );
    /// cvReleaseMat( &mat );
    /// return 0;
    /// }
    /// @endcode
    /// @param fs File storage
    /// @param name Name of the written object. Should be NULL if and only if the parent structure is a
    /// sequence.
    /// @param ptr Pointer to the object
    /// @param attributes The attributes of the object. They are specific for each particular type (see
    /// the discussion below).
    pub fn cvWrite(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_void,
        attributes: CvAttrList,
    );
}
extern "C" {
    /// @brief Starts the next stream.
    ///
    /// The function finishes the currently written stream and starts the next stream. In the case of XML
    /// the file with multiple streams looks like this:
    /// @code{.xml}
    /// <opencv_storage>
    /// <!-- stream #1 data -->
    /// </opencv_storage>
    /// <opencv_storage>
    /// <!-- stream #2 data -->
    /// </opencv_storage>
    /// ...
    /// @endcode
    /// The YAML file will look like this:
    /// @code{.yaml}
    /// %YAML 1.0
    /// # stream #1 data
    /// ...
    /// ---
    /// # stream #2 data
    /// @endcode
    /// This is useful for concatenating files or for resuming the writing process.
    /// @param fs File storage
    pub fn cvStartNextStream(fs: *mut CvFileStorage);
}
extern "C" {
    /// @brief Writes multiple numbers.
    ///
    /// The function writes an array, whose elements consist of single or multiple numbers. The function
    /// call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single
    /// call is more efficient. Note that because none of the elements have a name, they should be written
    /// to a sequence rather than a map.
    /// @param fs File storage
    /// @param src Pointer to the written array
    /// @param len Number of the array elements to write
    /// @param dt Specification of each array element, see @ref format_spec "format specification"
    pub fn cvWriteRawData(
        fs: *mut CvFileStorage,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Writes multiple numbers in Base64.
    ///
    /// If either CV_STORAGE_WRITE_BASE64 or cv::FileStorage::WRITE_BASE64 is used,
    /// this function will be the same as cvWriteRawData. If neither, the main
    /// difference is that it outputs a sequence in Base64 encoding rather than
    /// in plain text.
    ///
    /// This function can only be used to write a sequence with a type "binary".
    ///
    /// Consider the following two examples where their output is the same:
    /// @snippet samples/cpp/filestorage_base64.cpp without_base64_flag
    /// and
    /// @snippet samples/cpp/filestorage_base64.cpp with_write_base64_flag
    ///
    /// @param fs File storage
    /// @param src Pointer to the written array
    /// @param len Number of the array elements to write
    /// @param dt Specification of each array element, see @ref format_spec "format specification"
    pub fn cvWriteRawDataBase64(
        fs: *mut CvFileStorage,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Returns a unique pointer for a given name.
    ///
    /// The function returns a unique pointer for each particular file node name. This pointer can be then
    /// passed to the cvGetFileNode function that is faster than cvGetFileNodeByName because it compares
    /// text strings by comparing pointers rather than the strings' content.
    ///
    /// Consider the following example where an array of points is encoded as a sequence of 2-entry maps:
    /// @code
    /// points:
    /// - { x: 10, y: 10 }
    /// - { x: 20, y: 20 }
    /// - { x: 30, y: 30 }
    /// # ...
    /// @endcode
    /// Then, it is possible to get hashed "x" and "y" pointers to speed up decoding of the points. :
    /// @code
    /// #include "cxcore.h"
    ///
    /// int main( int argc, char** argv )
    /// {
    /// CvFileStorage* fs = cvOpenFileStorage( "points.yml", 0, CV_STORAGE_READ );
    /// CvStringHashNode* x_key = cvGetHashedNode( fs, "x", -1, 1 );
    /// CvStringHashNode* y_key = cvGetHashedNode( fs, "y", -1, 1 );
    /// CvFileNode* points = cvGetFileNodeByName( fs, 0, "points" );
    ///
    /// if( CV_NODE_IS_SEQ(points->tag) )
    /// {
    /// CvSeq* seq = points->data.seq;
    /// int i, total = seq->total;
    /// CvSeqReader reader;
    /// cvStartReadSeq( seq, &reader, 0 );
    /// for( i = 0; i < total; i++ )
    /// {
    /// CvFileNode* pt = (CvFileNode*)reader.ptr;
    /// #if 1 // faster variant
    /// CvFileNode* xnode = cvGetFileNode( fs, pt, x_key, 0 );
    /// CvFileNode* ynode = cvGetFileNode( fs, pt, y_key, 0 );
    /// assert( xnode && CV_NODE_IS_INT(xnode->tag) &&
    /// ynode && CV_NODE_IS_INT(ynode->tag));
    /// int x = xnode->data.i; // or x = cvReadInt( xnode, 0 );
    /// int y = ynode->data.i; // or y = cvReadInt( ynode, 0 );
    /// #elif 1 // slower variant; does not use x_key & y_key
    /// CvFileNode* xnode = cvGetFileNodeByName( fs, pt, "x" );
    /// CvFileNode* ynode = cvGetFileNodeByName( fs, pt, "y" );
    /// assert( xnode && CV_NODE_IS_INT(xnode->tag) &&
    /// ynode && CV_NODE_IS_INT(ynode->tag));
    /// int x = xnode->data.i; // or x = cvReadInt( xnode, 0 );
    /// int y = ynode->data.i; // or y = cvReadInt( ynode, 0 );
    /// #else // the slowest yet the easiest to use variant
    /// int x = cvReadIntByName( fs, pt, "x", 0 );
    /// int y = cvReadIntByName( fs, pt, "y", 0 );
    /// #endif
    /// CV_NEXT_SEQ_ELEM( seq->elem_size, reader );
    /// printf("
    /// }
    /// }
    /// cvReleaseFileStorage( &fs );
    /// return 0;
    /// }
    /// @endcode
    /// Please note that whatever method of accessing a map you are using, it is still much slower than
    /// using plain sequences; for example, in the above example, it is more efficient to encode the points
    /// as pairs of integers in a single numeric sequence.
    /// @param fs File storage
    /// @param name Literal node name
    /// @param len Length of the name (if it is known apriori), or -1 if it needs to be calculated
    /// @param create_missing Flag that specifies, whether an absent key should be added into the hash table
    pub fn cvGetHashedKey(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        create_missing: ::std::os::raw::c_int,
    ) -> *mut CvStringHashNode;
}
extern "C" {
    /// @brief Retrieves one of the top-level nodes of the file storage.
    ///
    /// The function returns one of the top-level file nodes. The top-level nodes do not have a name, they
    /// correspond to the streams that are stored one after another in the file storage. If the index is out
    /// of range, the function returns a NULL pointer, so all the top-level nodes can be iterated by
    /// subsequent calls to the function with stream_index=0,1,..., until the NULL pointer is returned.
    /// This function can be used as a base for recursive traversal of the file storage.
    /// @param fs File storage
    /// @param stream_index Zero-based index of the stream. See cvStartNextStream . In most cases,
    /// there is only one stream in the file; however, there can be several.
    pub fn cvGetRootFileNode(fs: *const CvFileStorage, stream_index: ::std::os::raw::c_int) -> *mut CvFileNode;
}
extern "C" {
    /// @brief Finds a node in a map or file storage.
    ///
    /// The function finds a file node. It is a faster version of cvGetFileNodeByName (see
    /// cvGetHashedKey discussion). Also, the function can insert a new node, if it is not in the map yet.
    /// @param fs File storage
    /// @param map The parent map. If it is NULL, the function searches a top-level node. If both map and
    /// key are NULLs, the function returns the root file node - a map that contains top-level nodes.
    /// @param key Unique pointer to the node name, retrieved with cvGetHashedKey
    /// @param create_missing Flag that specifies whether an absent node should be added to the map
    pub fn cvGetFileNode(
        fs: *mut CvFileStorage,
        map: *mut CvFileNode,
        key: *const CvStringHashNode,
        create_missing: ::std::os::raw::c_int,
    ) -> *mut CvFileNode;
}
extern "C" {
    /// @brief Finds a node in a map or file storage.
    ///
    /// The function finds a file node by name. The node is searched either in map or, if the pointer is
    /// NULL, among the top-level file storage nodes. Using this function for maps and cvGetSeqElem (or
    /// sequence reader) for sequences, it is possible to navigate through the file storage. To speed up
    /// multiple queries for a certain key (e.g., in the case of an array of structures) one may use a
    /// combination of cvGetHashedKey and cvGetFileNode.
    /// @param fs File storage
    /// @param map The parent map. If it is NULL, the function searches in all the top-level nodes
    /// (streams), starting with the first one.
    /// @param name The file node name
    pub fn cvGetFileNodeByName(
        fs: *const CvFileStorage,
        map: *const CvFileNode,
        name: *const ::std::os::raw::c_char,
    ) -> *mut CvFileNode;
}
extern "C" {
    /// @brief Decodes an object and returns a pointer to it.
    ///
    /// The function decodes a user object (creates an object in a native representation from the file
    /// storage subtree) and returns it. The object to be decoded must be an instance of a registered type
    /// that supports the read method (see CvTypeInfo). The type of the object is determined by the type
    /// name that is encoded in the file. If the object is a dynamic structure, it is created either in
    /// memory storage and passed to cvOpenFileStorage or, if a NULL pointer was passed, in temporary
    /// memory storage, which is released when cvReleaseFileStorage is called. Otherwise, if the object is
    /// not a dynamic structure, it is created in a heap and should be released with a specialized function
    /// or by using the generic cvRelease.
    /// @param fs File storage
    /// @param node The root object node
    /// @param attributes Unused parameter
    pub fn cvRead(
        fs: *mut CvFileStorage,
        node: *mut CvFileNode,
        attributes: *mut CvAttrList,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Initializes the file node sequence reader.
    ///
    /// The function initializes the sequence reader to read data from a file node. The initialized reader
    /// can be then passed to cvReadRawDataSlice.
    /// @param fs File storage
    /// @param src The file node (a sequence) to read numbers from
    /// @param reader Pointer to the sequence reader
    pub fn cvStartReadRawData(fs: *const CvFileStorage, src: *const CvFileNode, reader: *mut CvSeqReader);
}
extern "C" {
    /// @brief Initializes file node sequence reader.
    ///
    /// The function reads one or more elements from the file node, representing a sequence, to a
    /// user-specified array. The total number of read sequence elements is a product of total and the
    /// number of components in each array element. For example, if dt=2if, the function will read total\*3
    /// sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read
    /// repeatedly by repositioning the reader using cvSetSeqReaderPos.
    /// @param fs File storage
    /// @param reader The sequence reader. Initialize it with cvStartReadRawData .
    /// @param count The number of elements to read
    /// @param dst Pointer to the destination array
    /// @param dt Specification of each array element. It has the same format as in cvWriteRawData .
    pub fn cvReadRawDataSlice(
        fs: *const CvFileStorage,
        reader: *mut CvSeqReader,
        count: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_void,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Reads multiple numbers.
    ///
    /// The function reads elements from a file node that represents a sequence of scalars.
    /// @param fs File storage
    /// @param src The file node (a sequence) to read numbers from
    /// @param dst Pointer to the destination array
    /// @param dt Specification of each array element. It has the same format as in cvWriteRawData .
    pub fn cvReadRawData(
        fs: *const CvFileStorage,
        src: *const CvFileNode,
        dst: *mut ::std::os::raw::c_void,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Writes a file node to another file storage.
    ///
    /// The function writes a copy of a file node to file storage. Possible applications of the function are
    /// merging several file storages into one and conversion between XML, YAML and JSON formats.
    /// @param fs Destination file storage
    /// @param new_node_name New name of the file node in the destination file storage. To keep the
    /// existing name, use cvcvGetFileNodeName
    /// @param node The written node
    /// @param embed If the written node is a collection and this parameter is not zero, no extra level of
    /// hierarchy is created. Instead, all the elements of node are written into the currently written
    /// structure. Of course, map elements can only be embedded into another map, and sequence elements
    /// can only be embedded into another sequence.
    pub fn cvWriteFileNode(
        fs: *mut CvFileStorage,
        new_node_name: *const ::std::os::raw::c_char,
        node: *const CvFileNode,
        embed: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Returns the name of a file node.
    ///
    /// The function returns the name of a file node or NULL, if the file node does not have a name or if
    /// node is NULL.
    /// @param node File node
    pub fn cvGetFileNodeName(node: *const CvFileNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Registers a new type.
    ///
    /// The function registers a new type, which is described by info . The function creates a copy of the
    /// structure, so the user should delete it after calling the function.
    /// @param info Type info structure
    pub fn cvRegisterType(info: *const CvTypeInfo);
}
extern "C" {
    /// @brief Unregisters the type.
    ///
    /// The function unregisters a type with a specified name. If the name is unknown, it is possible to
    /// locate the type info by an instance of the type using cvTypeOf or by iterating the type list,
    /// starting from cvFirstType, and then calling cvUnregisterType(info-\>typeName).
    /// @param type_name Name of an unregistered type
    pub fn cvUnregisterType(type_name: *const ::std::os::raw::c_char);
}
extern "C" {
    /// @brief Returns the beginning of a type list.
    ///
    /// The function returns the first type in the list of registered types. Navigation through the list can
    /// be done via the prev and next fields of the CvTypeInfo structure.
    pub fn cvFirstType() -> *mut CvTypeInfo;
}
extern "C" {
    /// @brief Finds a type by its name.
    ///
    /// The function finds a registered type by its name. It returns NULL if there is no type with the
    /// specified name.
    /// @param type_name Type name
    pub fn cvFindType(type_name: *const ::std::os::raw::c_char) -> *mut CvTypeInfo;
}
extern "C" {
    /// @brief Returns the type of an object.
    ///
    /// The function finds the type of a given object. It iterates through the list of registered types and
    /// calls the is_instance function/method for every type info structure with that object until one of
    /// them returns non-zero or until the whole list has been traversed. In the latter case, the function
    /// returns NULL.
    /// @param struct_ptr The object pointer
    pub fn cvTypeOf(struct_ptr: *const ::std::os::raw::c_void) -> *mut CvTypeInfo;
}
extern "C" {
    /// @brief Releases an object.
    ///
    /// The function finds the type of a given object and calls release with the double pointer.
    /// @param struct_ptr Double pointer to the object
    pub fn cvRelease(struct_ptr: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Makes a clone of an object.
    ///
    /// The function finds the type of a given object and calls clone with the passed object. Of course, if
    /// you know the object type, for example, struct_ptr is CvMat\*, it is faster to call the specific
    /// function, like cvCloneMat.
    /// @param struct_ptr The object to clone
    pub fn cvClone(struct_ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Saves an object to a file.
    ///
    /// The function saves an object to a file. It provides a simple interface to cvWrite .
    /// @param filename File name
    /// @param struct_ptr Object to save
    /// @param name Optional object name. If it is NULL, the name will be formed from filename .
    /// @param comment Optional comment to put in the beginning of the file
    /// @param attributes Optional attributes passed to cvWrite
    pub fn cvSave(
        filename: *const ::std::os::raw::c_char,
        struct_ptr: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        comment: *const ::std::os::raw::c_char,
        attributes: CvAttrList,
    );
}
extern "C" {
    /// @brief Loads an object from a file.
    ///
    /// The function loads an object from a file. It basically reads the specified file, find the first
    /// top-level node and calls cvRead for that node. If the file node does not have type information or
    /// the type information can not be found by the type name, the function returns NULL. After the object
    /// is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a
    /// dynamic structure, such as a sequence, contour, or graph, one should pass a valid memory storage
    /// destination to the function.
    /// @param filename File name
    /// @param memstorage Memory storage for dynamic structures, such as CvSeq or CvGraph . It is not used
    /// for matrices or images.
    /// @param name Optional object name. If it is NULL, the first top-level object in the storage will be
    /// loaded.
    /// @param real_name Optional output parameter that will contain the name of the loaded object
    /// (useful if name=NULL )
    pub fn cvLoad(
        filename: *const ::std::os::raw::c_char,
        memstorage: *mut CvMemStorage,
        name: *const ::std::os::raw::c_char,
        real_name: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// helper functions for RNG initialization and accurate time measurement:
    /// uses internal clock counter on x86
    pub fn cvGetTickCount() -> int64;
}
extern "C" {
    pub fn cvGetTickFrequency() -> f64;
}
extern "C" {
    /// CPU capabilities
    pub fn cvCheckHardwareSupport(feature: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve/set the number of threads used in OpenMP implementations
    pub fn cvGetNumThreads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetNumThreads(threads: ::std::os::raw::c_int);
}
extern "C" {
    /// get index of the thread being executed
    pub fn cvGetThreadNum() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get current OpenCV error status
    pub fn cvGetErrStatus() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets error status silently
    pub fn cvSetErrStatus(status: ::std::os::raw::c_int);
}
extern "C" {
    /// Retrives current error processing mode
    pub fn cvGetErrMode() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets error processing mode, returns previously used mode
    pub fn cvSetErrMode(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets error status and performs some additional actions (displaying message box,
    /// writing message to stderr, terminating application etc.)
    /// depending on the current error mode
    pub fn cvError(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Retrieves textual description of the error given its code
    pub fn cvErrorStr(status: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Retrieves detailed information about the last error occurred
    pub fn cvGetErrInfo(
        errcode_desc: *mut *const ::std::os::raw::c_char,
        description: *mut *const ::std::os::raw::c_char,
        filename: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Maps IPP error codes to the counterparts from OpenCV
    pub fn cvErrorFromIppStatus(ipp_status: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type CvErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Assigns a new error-handling function
    pub fn cvRedirectError(
        error_handler: CvErrorCallback,
        userdata: *mut ::std::os::raw::c_void,
        prev_userdata: *mut *mut ::std::os::raw::c_void,
    ) -> CvErrorCallback;
}
extern "C" {
    /// Output nothing
    pub fn cvNulDevReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Output to console(fprintf(stderr,...))
    pub fn cvStdErrReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Output to MessageBox(WIN32)
    pub fn cvGuiBoxReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
/// < "           "
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplTileInfo {
    pub _address: u8,
}
